# Problem A

题目描述：在数轴上给出n个段落，试求不出现在这个段落中的数字

暴力做法O(n * m)：对于每个给出段落标记，最后扫一遍整个段落，没有被标记的即为答案

前缀和做法O(n + m)：对左端点标记1，右端点标记-1。这样在最后扫一遍整个区间维护即可

# Problem B

题目描述：给定原始串s，目标串t，要求通过特定的操作将s转换成t。给定的操作是交换相邻的两个元素。试求最少可以完成目标的次数，以及具体的操作。

dfs   O(1<<50)：复杂度爆炸，不可行

贪心：从左至右，依次匹配特定元素即可

# Problem C

题目描述：起初给定n个数字，对应于每个数字的有一个变换后数字，保证变换后的数字较之前变小了。给定一个最大容量。试求最小的变换次数，使得数字之和小于等于最大容量。

错误的贪心：本来想按照变换前或者变换后的顺序进行挑选，但是一直出错

正确的贪心：实际上应该对它们的差值进行排序，并且维护所有数字的和。这样一来具有了单调性，可解

# Problem D

题目描述：给定一个数字s，要从1, 2, 3..., n - 1这些数字中总挑选出m个数字，使得它们的和为s

我的sb做法：首先二分出来完全使用某个数字将会少于规定个数的数字的边界

之后再使用二分挑选出应该使用多少个较大数，多少个较小数，然后输出，需要注意的地方超级多

官方题解：认为答案由最大数，一个余数，多个1组成

实际上这也可以通过构造答案来产生。思考允许的最少数字个数，当个数增加时，明显是将最大数字进行了拆分，变成了余数以及1.

# Problem E

题目描述：规定一个星型为中心有一个*，上下左右有len个\*的星为长度为len的星型。给定一个图，试构造一些星型使得最终的图形与给定的图形一致。

我的做法就是标程：首先使用前缀和的思想，对于一个点维护其上下左右的最长*。之后得到该处可以延伸出来的最大星型。最后对每个星型验证即可。

本题的难度与B题一致。