# 5.11 

我觉得能用zkw线段树的时候，还是尽量用zkw线段树比较好

因为[C - Sereja and Brackets](http://codeforces.com/contest/380/problem/C) 这一道当初我非常害怕的题目，在使用zkw线段树之后，五分钟就写了出来。。

而如果使用指针线段树，至少至少也需要二十分钟，并且非常非常容易出BUG

# Problem 339D

很明显的树形结构

这一次我使用了zkw线段树来写，只是在得到目前在树中的哪一层的时候有点蠢

写的时候使用的办法是对于每一个索引，要乘以多少次2才能到达[n, 2*n)的范围

现在觉得其实可以把线段树数组开成结构体，同时存在一维表示这个结点所在的高度，只需要一遍预处理即可

# Problem 356A

题目描述：有一些骑士，排成一列要进行比赛，他们的编号从1 ～ n   现在按照时间顺序给出m组信息，形式为 `l, r, x`。表示在`l ~ r`这个范围内存活的骑士进行比赛，最终只有编号为 $x$ 的骑士获胜。在每场比赛结束之后，失败的骑士离去。现在要求在给出m组信息之后，输出每位骑士被谁打败

结点染色问题，包含有时间戳

当骑士尚未被打败的时候，认为上面的时间戳为0，打败他的骑士为0

当某个骑士被打败之后，修改当前的时间戳，修改打败他的骑士

当出现区间重复覆盖的时候，这个区间不可以被重复染色

---

在打印某个结点的最终结果的时候，应该从这个结点出发，访问所有覆盖到这个结点的父节点

寻找到一个最早的时间戳，找到这个时间戳对应的打败他的骑士即可

因为这里我使用 0 表示了没有被打败的状态，所以最早的时间戳应该使用一个相对较大的数字来表示

否则 0 会把其他时间戳覆盖掉

---

因为zkw线段树的下标是从 0 ~ n - 1进行标记的，而一般题目中的标记是1 ~ n；并且可以操作的区间是左闭右开，这就使得操作的时候存在一个转换，脑袋很容易糊掉

这个问题就将来慢慢总结吧

# Problem 459D

题目描述：定义一个函数$f(l, r, x) = \text{appearing times of x in range[l, r]}$， 试求`i j`个数

它们满足$f(1, i, a[i]) > f(j, n, a[j])$	

权值线段树

本题可以向逆序对靠拢，将原数组进行转化，得到两个新的数组。一个用来记录从左边开始到现在，目前的数出现了多少次，另外一个数组记录从右边到现在，这个数字出现了多少次

于是现在我可以从右至左的插入第二个数组的元素，而每次检验0 ～ 第一个数组对应位置元素区间内的和

---

虽然思路很清晰。。然而还是跟六个月前犯的错误一样。。整数溢出了。。

![Figure1](https://github.com/qhb1001/For-that-dream/blob/master/Codeforces/Segment%20Tree%20Problem/Figure1.png)

# Problem 61E

题目描述：给定一个包含n个元素的数列，试求取其中所有合法的三元组。合法三元组的定义如下：对于$(i, j, k)  \&(i < j < k) \& (a_i > a_j > a_k)$ 

本题仍然是一道跟逆序数有关的题目，只是这次权值线段树中存储的值发生了变化

首先使用一颗线段树，用来求取对应位置的逆序数，如此进行完之后，可以得到的一个逆序数数组

之后再对该逆序数数组建线段树，从左往右遍历，一边删除一边查询

# Problem 380C

题目描述：对于一个给定的包含有左括号和右括号的字符序列，同时给出m组查询，形式为`l, r`，要求对于每组查询，给出该范围内匹配的括号数量

如果使用递归版线段树，倒是可以很简单地解决这道题目，我决定试试。。

距离上一次写递归版线段树已经不知道是什么时候啦，这一次写大概花了两个小时的样子

中间出现了很多BUG，拼写错误啦，在query函数中mid值取错啦之类的

但是，尽管如此，感觉递归版线段树只要熟练了还是可以掌握的

从魏彦明那里知道递归版线段树在不少题目里面还是需要的，zkw线段树不可以取代递归版线段树的全部功能

然后回到这一道题目，我会努力把递归版线段树分析清楚的

---

build函数处理建树过程，需要随时对未访问到的子结点malloc，分配空间

与此同时要对结点中的变量初始化

query函数负责查询，当要根据目前结点的区间以及需要访问的区间两者间的关系进行分类讨论

并且此处的mid值要取的应该是结点区间的mid

---

针对本题，我觉得实质上是使用线段树来进行在线查询

对于每一个区间，答案的产生都必须使用这一特定区间的值来得到

但是毕竟是线段树，如果不进行任何优化，那么跟遍历这一个子段的复杂度没有区别，所以需要优化

而优化就产生在当某一个区间完全匹配时，可以使用建树时获得的值

---

实现上述思想的方法有两种，第二种过于麻烦，而且特别容易出错，所以决定不讲，有兴趣可以看380C_Failed.cpp。 表示这份代码可以AC

然后第一种做法就是针对于每一个查询区间，query函数return的是一个Node* 结点，代表了这块特定区间

这样做的原因是当需要访问的区间小于某块结点区间的时候，在这一层return之后，将会完全访问这一整块区间，而实际上某些值我们是访问不到的。

虽然每次return都需要malloc出一个新结点，但是仍然可以接受

# zkw懒惰标记最简单应用  — 区间最大值

递归版线段树的懒惰标记我已经忘光了。。所以就不对比了。。

zkw新开了一个数组用来记录懒惰标记

在update函数中，在对每一个非叶结点的懒惰标记更新，退出for循环之后，又对两边的结点使用了一个build

> build函数是对某个节点的所有父节点进行更新

再加上

> **Modification on interval [l, r) affects t[i] values only in the parents of border leaves: l+n and r+n-1 (except the values that compose the interval itself — the ones accessed in for loop).**

所以只需要对两端的结点build一下，就可以实现对整棵树的懒惰标记上移

关于为什么要将懒惰标记上移，是因为必须要把这一块子区间的影响扩展到整棵树，否则如果将来查询距离该区间很远的另一块区间、或者完全覆盖该区间的时候，可能因为该影响而改变原查询结果

在此之后，是query函数中首先应该进行的push函数

这个函数是把关心区间的所有父节点按照自上而下的顺序，将他们的懒惰标记下移

