# Problem A

#### hcx

目标位置确定，注意sort一下原序列

# Problem B

#### hcx

预处理列，然后遍历每一行，若这行存在某一列的值为1，则此行不可以删除。犯了未初始化的bug！

# Problem C

#### hcx

先对木板从小到大排序，如果`a[n]-a[1]>l`的话，则一定为0；否则定有解。找到第一个`a[i]-a[1]>l`，或者`i>m-k+1`的值，此时`i-1`为最大可以做完短板的木板。然后开始从后向前判断，如果`i>(n-cnt-1)*k+1`，那么`i=(n-cnt-1)*k+1`，（即，要满足前面的短木板都可以和更短的组成一组）。



博博发现的机智方法：

排0后，进行排序。然后从后向前遍历，需要满足可以刚好构成`k`个，和`a[i]-a[1]>l`的条件，直到找到n个为止。

# Problem D


### hcx

看错了题了！！！

二分枚举堆数，堆数最大是n（每个都是1的情况）。

对于堆数x的时候，

如果是`x<=h`，则此时`x`的最大高度就是`x`，能满足条件的最大数为`(1+x)*x/2`，和`n`判断即可。

如果`x>h`的时候，我们可以画出一个抛物线，（因为这是一个连续变化的，对于x堆来说，最大的情况就是先递增后递减的一个曲线，对于其他的来说，中间出现平的肯定面积会更小）。其实不是曲线，只是第一感觉是这个。

然后，我们再理性地具体画出。如果`x-h-1`是奇数，就是上面一个尖尖的三角形；否则上面有一个平平的等腰梯形。然后就可以求出这个最大面积啦！

优化：它的总和最大为1e18，也就是说最大堆数x的总和(1+x)*x/2<=1e18，所以堆数可以从1~2e9左右枚举，这样long long就不会爆啦！