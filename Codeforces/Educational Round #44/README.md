# Problem A

题目描述：固定每个棋子的最终位置，给定它们的初始位置，问最终将棋子们都放在对应位置最小需要的花费

#### hcx

目标位置确定，注意sort一下原序列

# Problem B

#### hcx

预处理列，然后遍历每一行，若这行存在某一列的值为1，则此行不可以删除。犯了未初始化的bug！

# Problem C

题目描述：给出n*k块木板，要用它们组成n个木桶，每个木桶有k块木板。给出每块木板的长度。定义木桶的容量与组成木板的最短木板长度一样。对木板的组合方案有两个限制：第一个是要求容量和尽可能大，另外一个是任意两个木桶的容量差不可以超过 L。问最终的木桶容量和。

#### qhb

由于关心的是最短板，所以首先排序

对于第一个限制，贪心来做的话就是尽量让小木板凑在一个木桶中

对于第二个限制，则规定了可以使用的最短板的范围

一个非常棒的贪心法是从大到小，对目前可用的木板cnt计数，当遇到可以使用的最短板时更新cnt，更新容量和

#### hcx

先对木板从小到大排序，如果`a[n]-a[1]>l`的话，则一定为0；否则定有解。找到第一个`a[i]-a[1]>l`，或者`i>m-k+1`的值，此时`i-1`为最大可以做完短板的木板。然后开始从后向前判断，如果`i>(n-cnt-1)*k+1`，那么`i=(n-cnt-1)*k+1`，（即，要满足前面的短木板都可以和更短的组成一组）。



博博发现的机智方法：

排0后，进行排序。然后从后向前遍历，需要满足可以刚好构成`k`个，和`a[i]-a[1]>l`的条件，直到找到n个为止。

# Problem D


#### hcx

看错了题了！！！

二分枚举堆数，堆数最大是n（每个都是1的情况）。

对于堆数x的时候，

如果是`x<=h`，则此时`x`的最大高度就是`x`，能满足条件的最大数为`(1+x)*x/2`，和`n`判断即可。

如果`x>h`的时候，我们可以画出一个抛物线，（因为这是一个连续变化的，对于x堆来说，最大的情况就是先递增后递减的一个曲线，对于其他的来说，中间出现平的肯定面积会更小）。其实不是曲线，只是第一感觉是这个。

然后，我们再理性地具体画出。如果`x-h-1`是奇数，就是上面一个尖尖的三角形；否则上面有一个平平的等腰梯形。然后就可以求出这个最大面积啦！

优化：它的总和最大为1e18，也就是说最大堆数x的总和(1+x)*x/2<=1e18，所以堆数可以从1~2e9左右枚举，这样long long就不会爆啦！