# Problem A

#### qhb

简单模拟

# Problem B

#### qhb

应该算是离散化计数技巧的简单应用

# Problem D

#### hcx

DP问题，其实还好啦！

对于一个'('可以选择和')'交换或者不换。

先用前缀和记录每一个'('交换到每一个‘)’位置得到的价值。

因为左边的‘(’可以交换的位置上界受他右边的‘(’交换到的位置的影响。所以我重新给它标号。$DP[i][j]$表示倒数第$i$个'('交换到倒数第$j$个')'所能得到的价值。

递推关系式：

　　　　　　　　　$dp[i][j]=dp[i-1][j]+v[i][j];$

　　　　　　　　	 $ if(j!=1)		 dp[i][j]=max(dp[i][j],dp[i][j-1]);$

# Problem E

题目描述：在我们平时使用dp来解决最长上升子串时，会得到一个辅助数组dp[]，它表示以该下标结尾的元素，最长可以得到的上升子串。在这一道题目里面，在未知原数组的情况下，给出这个dp[]数组，同时给出每一个元素的上下界，请求确认一种可能的赋值，每个元素在给定范围之内，同时可以得到dp[]数组。

#### qhb

思维题，考智商

我，智商不够。。

给定的dp[]数组可以得到哪些有用的信息？

* For any `i`, if there exists `j < i && dp[j] == dp[i]`, then `a[j] >= a[i]`
* For any `i`, if there exists `j < i && dp[j] == dp[i] + 1`, then `a[i] > a[j]`

通过这两条信息，实际上可以确定`a[i]`元素的上下界

但是有一个很有意思的地方

对于可以确定上界的第一条规则，如果从左往右推，那么可以确定上界

可是如果从右往左推，则可以进一步确定下界

而很明显，当两条规则都用来确定下界时，最终可以的下界必定是答案

---

或者说，上述的规则都需要从两个方面来看

对第一条规则，当从左往右推的时候，不仅要考虑目前更新的元素a[i]，同时也要通过a[i]的下限来更新a[j]的下限

# Problem M

#### qhb

原形可以算是从Uva1614那边变过来的，使用那一道题目的结论即可

或者也可以直接匹配，拿第一个元素和最后一个元素放到一个集合，第二个和倒数第二个元素放到一个集合...

# Problem K

#### qhb

大模拟。。。

仔细分析各种情况的话应该不会错

然后在写的时候纠结了很长时间，栽到了一个小case上面，分析错误了

唔，大模拟似乎也没有那么可怕…?

# Problem L

#### qhb

贪心+排序

# Problem M

#### qhb

大水题