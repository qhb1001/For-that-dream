# Problem F

#### hcx

表示很绝望……记忆要不就更烂一点 要不就更好一点吧

优先队列的用处是什么呢？问了自己很久发现，我优先的是它下一个的位置，也就是说，如果下一个它出现的早，我就不应该弹出它，（也可以弹出之后，再加入）。

所以我需要先初始化它下一个位置在哪里，这里也需要用离散化的思想。

---

#### qhb

我也很绝望呀！

对拍了一个`50 10`的数据，打断点一点一点看。。。终于发现了自己的错误

当出现一个已经在优先队列里面的元素的时候，不可以直接continue！

是需要更新这个元素的下一个出现的位置的！

然后用我的思路的话，优先队列就没办法搞了呀！必须使用set！

同时维护一个`toDelete`队列，表示这个元素在之后的位置不再存在了

`set`的作用只是按照下标进行排列

当遇到已经拿在冰箱外面的物品时，找到这个物品，更新其下一个坐标

对于如何得到每一个元素的下一个位置，我使用了一个`stack`进行维护

# Problem G

#### qhb

题目描述：给出一个包含n（<=2000）个元素的序列，试求其中有多少个子串，其和可以被其中的每个元素整除

关键的问题是，如果得到了某一个串的和，如何快速地验证是否可以被子串中的每一个元素整除

采用的方法是最小公倍数。。。似乎是最小公倍数的简单应用

# Problem H

#### hcx

对于奇数的时候，要注意可能最后只剩下一位了，就不需要平分了，很绝望呀！

