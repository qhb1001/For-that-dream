# 主席树介绍

该算法存在的目的是为了能够便于对历史版本的数据进行访问，并且在其中快速地访问第k小元素，具体的优先级可以人为修订。

在实现上面，考虑一个经典的问题：任意区间[l, r]的第k小

在这个问题上，我们可以将[1, i]这n个区间，视为n棵不同的线段树，分别表示不同的历史版本

此时树的结构与正常地查询整个区间第k小值的线段树结构一致

注意到当插入一个结点时，只修改了$logn$个结点，所以可以新创建这些个结点，连向新的根  

 ==只有创建没有删除!!!==

# 注意的地方

* 根结点的大小开成数组中元素的个数，每个代表一棵新的线段树

* build函数首先需要建立一棵空树，表示第一个历史版本

* build函数的声明 `void build(int &i, int l, int r)`

* update函数 `int update(int i, int l, int r, int idx)`

* lower_bound函数，返回第一个小于或等于给定元素的位置，如果没有找到，那么返回最后一个越界索引

  如对于a[1..n] 调用，发生越界，那么返回的结果在 n + 1

* unique函数，对有序数组去重，返回的可以认为是最后一个越界索引

  如对于a[1...n]调用，正确得到其去重后结果的大小应该是

  `int len = unique(a + 1, a + 1 + n) - a - 1;`

* u 和 v 不要写反。。如果写反了，那么答案里面可能会生成负数

* 对于每一次新的时间轴，一定要继承上一次的状态

  因为有的题目时间轴是跳着的，如果仅对时间轴进行操作，每次从上一个状态转移而来，将会丢失状态

* 此处函数之间传递的`l & r`与线段树不一样，当时传递的是关心的区间，此时传递的是当前结点对应的区间

* 对多组数据，记得每次要把cnt清零，否则必定出现数组越界

  数组越界的另外一个可能是数组开小了

  数组越界的返回结果可能是 TLE

  因为每次创建新树至多新加入了 $2*log_2(n)$个结点，所以最保险的做法就是用最大容量乘以左边的数字

# hdu 4417

题目描述：查询[l, r]区间中有多少个值小于等于给定的值

不同于经典题目要求的查询第k小具体是什么数据，本题要求给出满足某条件的数据个数

累计加和即可，注意给定的值也许不在第一次的离散化结果中，所以需要特判

```c++
scanf("%d%d%d", &l, &r, &k); ++l; ++r;
t = lower_bound(b + 1, b + 1 + len, k) - b;
if (t == len + 1)  ans = r - l + 1;
else if (t == 1 && b[1] != k)   ans = 0;
else {
    if (b[t] != k) --t;
    ans = query(root[l - 1], root[r], 1, len, t);
}
```

至于query函数，也需要进行改动

```c++
int query(int u, int v, int l, int r, int k) {
    int x = sum[L[v]] - sum[L[u]];
    if (l == r) return sum[v] - sum[u];
    int mid = l + r >> 1;
    if (k <= mid) return query(L[u], L[v], l, mid, k);
    else return x + query(R[u], R[v], mid + 1, r, k);
}
```

# bzoj 3932

统计一个区间中最小的k个数字的加和

在主席树的结点中维护两个值 $num[MAX<<7]$  & $sum[MAX<<7]$

之后就是常规的统计操作

只是时间轴可能是间隔的。。。每一步必须继承上一次的状态

```c++
for (int i = 1; i <= n; ++i) {
    bool flag = true;
    while (cnt_ <= m*2 && c[cnt_].t == i) {
        s = lower_bound(b + 1, b + 1 + len, c[cnt_].val) - b;
        int ttt = c[cnt_].val;
        root[i] = update(root[i - flag], 1, len, s, c[cnt_].val, c[cnt_].type);
        flag = false;
        ++cnt_;
    }
    if (flag)   root[i] = root[i - 1];  
}
```



# hdu 5919

要求统计给定区间中第一次出现的数字的索引，将这些索引构成一个数列，求其中间那个位置的数字

又不同于以往的统计，因为以前的不会对历史数据进行修改

但是该题从左到右进行插入的时候，可以发现历史的数据将会发生改变，使得无法使用差分操作

但是似乎存在一个广为人知的技巧，那就是从右往左插入数据，同时不再使用主席树的差分功能

这样操作的话，对于以$root[l]$为根的这样一棵线段树，可以发现其左边不存在多余的数据，右边倒是会存在多余的数据。但是那些数据完全通过在这样的一棵线段树上面操作来去除

所以这样做的话，实际上是得到了n棵线段树，并且不再使用其差分功能

# spoj 3267

要求统计一个区间中包含有多少个不同的数字

其实这道题目是上一题的简化版本，上一题的另外一个要求是输出对应位置的数据

这样一来，不论是从左边开始插入，还是从右边开始插入都无所谓了

如果是从左边插入，那么root[r] 就是期望的线段树，否则root[l] 就是期望的线段树

上述两题的主席树不再是权值线段树，而是将下标作为索引的线段树



# zoj 2112

智障评测机不知道为什么一直给我段错误，但是我觉得自己的代码没有任何问题!(理直气壮.png

这道题目是带修改的区间第k小查询，使用了树状数组套线段树来解决

之所以这么说，是因为此时树状数组的每一个结点都是一棵线段树

当需要对某个位置上的值进行修改时，在树状数组中所有包含该位置的结点的数据进行更新

将来查询的时候，只需要使用树状数组前缀和的性质，得到包含某区间的所有线段树，将它们进行加和即可

神奇的算法