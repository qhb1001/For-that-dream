算法的主体是一个简单的dfs，实现上面如果使用邻接矩阵来存储图，将会达到$O(n^2)$的复杂度，而如果使用multiset来存储图，可以达到$O(nlgn)$的复杂度

欧拉路径的存在条件：只有两个结点的度数为奇数

欧拉回路的存在条件：整个图联通，所有结点的度数为偶数

如果是第一种情况，那么在调用dfs时应该从两个奇数度结点之一调用

后者的话则任意

一般来说，题目里会要求打印字典序最小的路径，所以一般都是选择最小度开始打印



算法具体的操作：

遍历到一条边之后，将该边删除，遍历另外一个结点；for结束之后，将该点入栈

最后按照栈的顺序输入欧拉路径即可

```c++
void dfs(int u) {
    char v;
    char c =u;
    for (auto x = G[u].begin(); x != G[u].end(); x = G[u].begin()) {
        v = *x;
        G[u].erase(x);
        G[v].erase(G[v].find(u));
        dfs(v);
    }
    ans.push(u);
}
```

