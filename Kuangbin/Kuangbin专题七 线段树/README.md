### qhb的个人笔记!~ 使用zkw线段树需要注意的地方

1. 首先是记得要把数组开成最大存储的两倍，毕竟是要建树

2. 在build函数和update函数中，两者的实现方式尽管都是自下而上，但是仍然有差别

   在build函数中，进行的是自下而上遍历所有的根结点，使用它们的子结点来进行更新。同时，要注意到这一课线段树最上面的根结点是1，所以在1的地方停止

   ```c++
   void build() {
    	for(int i = n - 1; i > 0; --i)
           t[i] = t[i<<1] + t[i<<1|1];//因为知道'i<<1'是一个偶数，所以对于另外一个子结点就是或
   }
   ```

   在update函数中，使用的是从子结点得到跟结点，再使用子结点更新根结点的方式

   ```c++
   void update(int x, int val) {
       for(t[x += n] = val; x > 1; x >>= 1) 
           t[x>>1] = t[x] + t[x^1];
   }
   ```

   因为此处使用的始终是从子结点得到根节点再更新，所以在x为1之前停止。也就是说，不可以更新x为1的情况。

3. 使用zkw线段树，是不需要对线段树数组进行初始化的，因为所有需要使用到的值都会在build函数和读入数据的时候完成更新。

4. 今天又看了下CF上面的线段树教程，发现zkw线段树是可以非常非常灵活的

   之前的合并括号题目，完全可以使用zkw线段树来搞

   之前是通过每一次递归地搞，针对每一个子段，返回一个结构体

   但是使用zkw线段树的时候，是可以自己定义出一个combine函数，对于每一个区间中的括号进行合并的！

5. zkw线段树懒惰标记学习！

   首先定义一个树的高度`int h = sizeof(int) * 8 - __builtin_clz(n);`

   然后再定义一个存储懒惰标记的数组`d[n]`

   * 给出一个结论：当对某个区间进行修改操作之后，这个修改操作对整棵树的影响，可以通过对`l + n`, `r + n - 1`这两个边界，自底向上更新，就可以完成对整棵树的更新

     所以在这里给出build函数

     ```c++
     void build(int p) {
         while (p > 1) p >>= 1, t[p] = max(t[p<<1], t[p<<1|1]) + d[p];    
     }
     ```

     该函数不仅可以建树，还可以更新某次修改对整棵树的影响，保持整棵树的一致性

   * 现在给出`apply`函数，该函数是区间修改操作中对某一块选中区间的更新

     ```c++
     void apply(int p, int value) {
         t[p] += value;
         if (p < n)	d[p] += value;
     }
     ```

   * 现在给出`modify`函数，表示对某一块区间进行修改操作

     ```c++
     void modify(int l, int r, int value) {
         l += n; r += n;
         int l0 = l, r0 = r - 1;
         for (; l < r; l >>= 1, r >>= 1) {
             if (l&1)	apply(l++, value);
             if (r&1)	apply(--r, value);
         }
         build(l0);
         build(r0);
     }
     ```

   * 给出push函数，用于从根结点开始，对所有包含某个叶结点的区间进行更新

     ```c++
     void push(int p) {
         for (int s = h; s > 0; --s) {
             int i = p >> s;
             if (d[i] != 0) {
                 apply(i<<1, d[i]);
                 apply(i<<1|1, d[i]);
                 d[i] = 0;
             }
         }
     }
     ```

     

   * 有了上面那些函数之后，就可以进行查询了

     ```c++
     int query(int l, int r) {
         l += n;
         r += n;
         push(l); push(r - 1);
         int ans = -(1<<30);
         for (; l < r; l >>= 1, r >>= 1) {
             if (l&1)	ans = max(ans, t[l++]);
             if (r&1)	ans = max(ans, t[--r]);
         }
         return ans;
     }
     ```

     

# Problem E

#### qhb

第一次使用zkw线段树完成结点染色问题，写起来真是方便啊

然后在实现的思路上面，跟正常的递归式线段树差不多，只是这里为自下而上地传递标记而已

类似于求区间和，进行颜色标记的时候，是对满足某种性质的结点进行操作

在最后需要得到整个区间的颜色情况时，需要一个push函数，作用是把所有的标记都进行下移

注意，标记是有先后顺序的，必须同时维护一个时间戳，表示区间颜色的先后问题

# Problem F

#### qhb

这是一道区间染色的问题，跟上面的对结点染色情况不同，此时应该把每一个长度为1的染色区间视为一个结点。这样以来，就可以又回归为结点染色问题了

这样做的原因是对区间染色比较烦，并且线段树的叶子保存的本来就是结点，如果在区间染色问题里面再把线段树的叶子视为区间，那么会非常抽象，思考起来对人类不友好

本题的数据似乎有些水，因为看不到使用递归版线段树和zkw线段树的差别

# Problem H

#### qhb

相对于上题的时间戳，本题的区间操作是永久性操作，不存在覆盖的性质

并且由于在区间修改操作中，还间隔存在着查询操作，所以就必须在每次区间操作之后，加上一个up操作

来实现由于本次修改操作对原树造成的影响上传，保持整棵树的一致性

---

本题我使用了对拍的方法来发现这个问题