[TOC]

# qhb的个人笔记!~ 使用zkw线段树需要注意的地方

1. 首先是记得要把数组开成最大存储的两倍，毕竟是要建树

2. 在build函数和update函数中，两者的实现方式尽管都是自下而上，但是仍然有差别

   在build函数中，进行的是自下而上遍历所有的根结点，使用它们的子结点来进行更新。同时，要注意到这一课线段树最上面的根结点是1，所以在1的地方停止

   ```c++
   void build() {
    	for(int i = n - 1; i > 0; --i)
           t[i] = t[i<<1] + t[i<<1|1];//因为知道'i<<1'是一个偶数，所以对于另外一个子结点就是或
   }
   ```

   在update函数中，使用的是从子结点得到跟结点，再使用子结点更新根结点的方式

   ```c++
   void update(int x, int val) {
       for(t[x += n] = val; x > 1; x >>= 1) 
           t[x>>1] = t[x] + t[x^1];
   }
   ```

   因为此处使用的始终是从子结点得到根节点再更新，所以在x为1之前停止。也就是说，不可以更新x为1的情况。

3. 使用zkw线段树，是不需要对线段树数组进行初始化的，因为所有需要使用到的值都会在build函数和读入数据的时候完成更新。

4. 今天又看了下CF上面的线段树教程，发现zkw线段树是可以非常非常灵活的

   之前的合并括号题目，完全可以使用zkw线段树来搞

   之前是通过每一次递归地搞，针对每一个子段，返回一个结构体

   但是使用zkw线段树的时候，是可以自己定义出一个combine函数，对于每一个区间中的括号进行合并的！

5. zkw线段树懒惰标记学习！

   首先定义一个树的高度`int h = sizeof(int) * 8 - __builtin_clz(n);`

   然后再定义一个存储懒惰标记的数组`d[n]`

   * 给出一个结论：当对某个区间进行修改操作之后，这个修改操作对整棵树的影响，可以通过对`l + n`, `r + n - 1`这两个边界，自底向上更新，就可以完成对整棵树的更新

     所以在这里给出build函数

     ```c++
     void build(int p) {
         while (p > 1) p >>= 1, t[p] = max(t[p<<1], t[p<<1|1]) + d[p];    
     }
     ```

     该函数不仅可以建树，还可以更新某次修改对整棵树的影响，保持整棵树的一致性

   * 现在给出`apply`函数，该函数是区间修改操作中对某一块选中区间的更新

     ```c++
     void apply(int p, int value) {
         t[p] += value;
         if (p < n)	d[p] += value;
     }
     ```

   * 现在给出`modify`函数，表示对某一块区间进行修改操作

     ```c++
     void modify(int l, int r, int value) {
         l += n; r += n;
         int l0 = l, r0 = r - 1;
         for (; l < r; l >>= 1, r >>= 1) {
             if (l&1)	apply(l++, value);
             if (r&1)	apply(--r, value);
         }
         build(l0);
         build(r0);
     }
     ```

   * 给出push函数，用于从根结点开始，对所有包含某个叶结点的区间进行更新

     ```c++
     void push(int p) {
         for (int s = h; s > 0; --s) {
             int i = p >> s;
             if (d[i] != 0) {
                 apply(i<<1, d[i]);
                 apply(i<<1|1, d[i]);
                 d[i] = 0;
             }
         }
     }
     ```

     

   * 有了上面那些函数之后，就可以进行查询了

     ```c++
     int query(int l, int r) {
         l += n;
         r += n;
         push(l); push(r - 1);
         int ans = -(1<<30);
         for (; l < r; l >>= 1, r >>= 1) {
             if (l&1)	ans = max(ans, t[l++]);
             if (r&1)	ans = max(ans, t[--r]);
         }
         return ans;
     }
     ```

     



# 数组线段树

不行不行，zkw线段树实在是太高深了，目前没办法掌握。开始学习数组版线段树

1. 懒惰标记 多校训练第五场 1007

   给定一个长度为n的数组，初始其中元素全部为0。给定操作`l, r, val` 表示将`[l, r]`区间内的元素，如果值小于val，那么将其设置为val。在全部操作结束之后需要对元素进行遍历。

   ```c++
   const int MAX = 1e5 + 5;
   struct Node {
       int l, r;
       long long val, Min, lazy;
   }t[MAX<<2];
   
   void build(int i, int l, int r) {
       t[i].l = l;
       t[i].r = r;
       t[i].val = t[i].Min = t[i].lazy = 0;
       if (l == r) return ;
       int mid = (l + r) >> 1;
       build(i<<1, l, mid);
       build(i<<1|1, mid + 1, r);
   }
   void push(int i) {
       if (t[i].lazy != 0) {
           t[i<<1].lazy = t[i<<1|1].lazy = t[i].lazy;
           t[i<<1].val = t[i<<1|1].val = t[i].lazy;
           t[i<<1].Min = t[i<<1|1].Min = t[i].lazy;
           t[i].lazy = 0;
       }
   }
   void up(int i) {
       t[i].val = max(t[i<<1].val, t[i<<1|1].val);
       t[i].Min = min(t[i<<1].Min, t[i<<1|1].Min);
   }
   void update(int i, int l, int r, long long val) {
       if (t[i].Min >= val)    return ;
       if (t[i].l == l && t[i].r == r) {
           if (t[i].val < val) {
               t[i].lazy = t[i].val = t[i].Min = val;
               return ; //注意val不是代表整个区间的值，而是整个区间的最大值
           }
       } 
       
       int mid = (t[i].l + t[i].r) >> 1;
       push(i);
       if (r <= mid)   update(i<<1, l, r, val);
       else if (l > mid) update(i<<1|1, l, r, val);
       else {
           update(i<<1, l, mid, val);
           update(i<<1|1, mid + 1, r, val);
       }
       up(i);
   }
   
   long long a[MAX];
   void query(int i) {
       if (t[i].val == t[i].Min) {
           for (int k = t[i].l; k <= t[i].r; ++k) {
               a[k] = t[i].val;
           }
           return ;
       }
   
       push(i);
       query(i<<1); query(i<<1|1);
   }
   ```

   

2. 区间加和，查询区间和 POJ 3486

   具体注意的地方有在对各个区间进行区间加和时，某个结点的两个子结点的长度不一定相等

   具体在代码里面就是

   ```c++
   void push(int i) {
       if (t[i].lazy) {
           int len = t[i<<1].r - t[i<<1].l + 1;
           t[i<<1].lazy += t[i].lazy;
           t[i<<1].sum += len * t[i].lazy;
           len = t[i<<1|1].r - t[i<<1|1].l + 1;
           t[i<<1|1].lazy += t[i].lazy;
           t[i<<1|1].sum += len * t[i].lazy;
           t[i].lazy = 0;
       }
   }
   ```

   ---

   此外，重新申明一下懒惰标记的使用方法

   在进行`up(i)`之前，必须保证当前结点的懒惰标记已经下传

   在进入子区间进行更新前，必须将当前结点的懒惰标记下传，即使用`push(i)`

   只有时刻保证上面两点，才可以始终保证区间和的正确性

   

   同时，在`query(1, l, r)`函数中，在进入子结点前，必须保证懒惰标记的下移



# Problem E

#### qhb

第一次使用zkw线段树完成结点染色问题，写起来真是方便啊

然后在实现的思路上面，跟正常的递归式线段树差不多，只是这里为自下而上地传递标记而已

类似于求区间和，进行颜色标记的时候，是对满足某种性质的结点进行操作

在最后需要得到整个区间的颜色情况时，需要一个push函数，作用是把所有的标记都进行下移

注意，标记是有先后顺序的，必须同时维护一个时间戳，表示区间颜色的先后问题

# Problem F

#### qhb

这是一道区间染色的问题，跟上面的对结点染色情况不同，此时应该把每一个长度为1的染色区间视为一个结点。这样以来，就可以又回归为结点染色问题了

这样做的原因是对区间染色比较烦，并且线段树的叶子保存的本来就是结点，如果在区间染色问题里面再把线段树的叶子视为区间，那么会非常抽象，思考起来对人类不友好

本题的数据似乎有些水，因为看不到使用递归版线段树和zkw线段树的差别

# Problem H

#### qhb

相对于上题的时间戳，本题的区间操作是永久性操作，不存在覆盖的性质

并且由于在区间修改操作中，还间隔存在着查询操作，所以就必须在每次区间操作之后，加上一个up操作

来实现由于本次修改操作对原树造成的影响上传，保持整棵树的一致性

---

本题我使用了对拍的方法来发现这个问题

# Problem I

#### qhb

题目描述：对于一段连续的n个工作站，初始的时候它们全部联结。

给出三个操作1. 摧毁某座工作站 2. 修复某座工作站 3. 查询与某座工作站连通的工作站数量





摧毁工作站和修复工作站可以很方便地完成，但是查询操作需要多思考一下

针对每个节点维护该区间对应的工作站是否全部工作

然后在查询步骤，我们关心的是关键点所在的区间，所以在递归过程中可以划分为一下步骤

* 找到该关键点所在的最小连通区间
* 向上返回包含关键点的区间的连通信息，是否与左侧区间相连，或者是否与右侧区间相连
* 如果相连，使用一个新的函数，得到对应区间的最左边或者最右边的那个连通快大小

本题即破



# Problem J

#### qhb

题目描述：给出一棵树，表示的是上级与下级的关系。已知当给某个人分配任务之后，这个人会把任务分散给他的所有下级

给出两种操作1. 给某个人分配任务 2. 查询某个人当前的任务编号



我通过将原来树中的结点编号进行一个新的映射，将树的信息全部转换到了线段树中

一个人的下级我通过遍历整棵树来得到一块连续区间

本题即破

这应该是一个技巧，因为我发现这个区间的转换可以很方便地完成

# Problem N

#### qhb

扫描线求矩形周长并



以前我认为要维护的东西是一个区间上被覆盖了多少次、被覆盖的长度；虽然现在也是这么想的，但是当时对本题这种特殊的性质欠缺了思考：每次出现出边时，在此之前这一条边一定已经被覆盖了

所以对于区间上被覆盖长度的维护，可以直接用

```c++
if (t[i].times)	t[i].len = t[i].r - t[i].l + 1;
else if (t[i].l == t[i].r)	t[i].len = 0;
else	t[i].len = t[i<<1].len + t[i<<1|1].len;
```

如此一来，本题即破

但是很奇怪的是，如果我严格扣住线段树的边界大小，将会RE

细细想来，线段树必须是一棵完全二叉树，当出现越界情况时似乎也应该处理

可是如果将线段树的边界设置为最大，并且对于每个坐标将它们的值都加上最小值，得到AC

将这个东西放到BUG总结里面吧