# hdu 6447

题目描述：在一个很大的坐标系上面给出n个村庄，当从左下角进入村庄的时候，可以获得一定的收益。起始从(0, 0)点出发到达(1e9, 1e9)这个点，试求最大化的收益

首先可以很明确地看出来这是一个动态规划，但是在比赛的时候没有写出来，因为这样灵活的使用树状数组想不出来。。。

或者说，对动态规划的认识还是浅了点

列出状态转移方程 $dp[i][j] = max(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1] + val_i)$

于是考虑使用树状数组来动态地维护，y值从小到大进行遍历，树状数组中的元素表示离散化之后的x值

意义为目前该处的x值可以取得的最大收益

如果在遍历某一层y的时候，首先只进行取最大值而不更新的话，就可以完成该层dp的更新

之后再继续进行更新即可

具体实现的时候我使用了双指针搜索在同一层的y(感觉自己很优雅

```c++
while (true) {
    l = r++;
    while (r <= n && p[r].y == p[l].y) ++r;
    if (r == n + 1) flag = true;

    int Max = 0;
    for (int i = l; i < r; ++i) {
        dp[i] = query(p[i].x - 1) + p[i].val;
        dp[i] = max(dp[i], query(p[i].x));
        dp[i] = max(dp[i], Max);
        Max = max(Max, dp[i]);
    }
    for (int i = l; i < r; ++i) update(p[i].x, dp[i]);
    if (flag)   break;
}
```

# 洛谷 1280

正着来写的话，很明显应该将状态表示为$dp[i]$表示$[1,   i]$时间段可以达到的最短时间，但是由于当前任务安排上了之后将会影响之后的决策，具有后效性

所以考虑从后往前进行递推，对于目前枚举到的时间点，它可以到达的最大空闲时间，应该是向上回溯，找到其结束的时间点，从该点进行转移，这样的话对接下来的决策没有影响

# 洛谷 1941

注意点

* 如果某个x坐标上有障碍，注意第一次的落脚点的选取