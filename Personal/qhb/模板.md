[TOC]

# JAVA大数

### 使用大整数的compareTo()函数

```java
import java.util.*;
import java.math.*;
import java.lang.*;
public class Main{
    public static void main(String[] args) {
        Scanner cin = new Scanner(System.in);
        BigInteger ans[] = new BigInteger[2005];
        ans[1] = BigInteger.ONE;
        ans[2] = BigInteger.ONE.add(ans[1]);
        for(int i = 3; i < 2000; ++i){
            ans[i] = ans[i - 1].add(ans[i - 2]);
            if(ans[i].toString().length() > 100)   {
                break;
            }
        }
        BigInteger a, b;
        while(true) {
            a = cin.nextBigInteger();
            b = cin.nextBigInteger();
            if(a.compareTo(BigInteger.ZERO) == 0 && b.compareTo(BigInteger.ZERO) == 0) break;
            int c = 0;
            for(int i = 1; i <= 480; ++i)
                if(a.compareTo(ans[i]) <= 0 && ans[i].compareTo(b) <= 0) ++c;
            System.out.println(c);
        }
    }
}
```

### 使用大浮点数的内建方法

```java
import java.util.*;
import java.math.*;
import java.lang.*;
public class Main{
    public static void main(String[] args) {
        BigDecimal ans;
        int n;
        Scanner cin = new Scanner(System.in);
        while(cin.hasNext()) {
            ans = cin.nextBigDecimal();
            n = cin.nextInt();
            String a = ans.pow(n).stripTrailingZeros().toPlainString();
            while(a.charAt(0) == '0')  a = a.substring(1);
            System.out.println(a);
        }
    }
}
```

### 使用自带的Miller Rabin方法

```java
public class Main {
    public static void main(String[] args) {
        InputReader reader = new InputReader();
        PrintWriter out = new PrintWriter(System.out);
        int t = reader.nextInt();
        while (t-- > 0) {
            long n = reader.nextLong();
            long half = n / 2;
            int get = (int) (half % 10);
            // if (isPrime(n - 5)) {
            // if (Miller_Rabin(n - 5)) {
            if (BigInteger.valueOf(n - 5).isProbablePrime(5)) {
                out.println(5 + " " + (n - 5));
                continue;
            }
            while (half > 0) {
                // System.out.println(half);
                if (get == 1 || get == 7 || get == 9 || get == 3) {
                    // if (isPrime(get)) {
                    // if (Miller_Rabin(half)) {
                    if (BigInteger.valueOf(half).isProbablePrime(5)) {
                        long half2 = n - half;
                        long get2 = half2 % 10;
                        if (get2 == 1 || get2 == 7 || get2 == 9 || get2 == 3) {
                            // if (isPrime(half2)) {
                            // if (Miller_Rabin(half2)) {
                            if (BigInteger.valueOf(half2).isProbablePrime(5)) {
                                out.println(half + " " + half2);
                                break;
                            }
                        }
                    }
                }
                half--;
                get = (int) (half % 10);
            }
        }
        out.close();
    }
}
```

### 使用String初始化BigInteger

```java
BigInteger now = new BigInteger("100000");
```



# 矩阵模板(注意在需要的地方改long long)

```c++
struct Mat{
    int row, col ,N[25][25];
    Mat(int row = 0 , int col = 0){
        memset(N, 0, sizeof(N));
        this -> row = row;
        this -> col = col;
    }
    Mat operator * (const Mat B) const {
        Mat A(row, B.col);
        for(int i = 0 ;i < row; i ++)
            for(int k = 0 ; k < col; k ++)
                for(int j = 0 ; j < B.col; j++){
                    A.N[i][j] = A.N[i][j] + N[i][k] * B.N[k][j] ;
                }
        return A;
    }
    Mat operator ^ (int x) const {
        Mat A(row,row) , temp = *this;
        for(int i = 0 ; i < row; i ++)  A.N[i][i] = 1;
        while(x){
            if(x & 1)   A = A * temp;
            temp = temp * temp;
            x>>= 1;
        }
        return A;
    }
};
```

# KMP

```C++
void getNext(string &a) {
    int i = 0, j = -1, len = a.size();
    Next[0] = -1;
    while(i < len) {
        if(j == -1 || a[i] == a[j]) {
            Next[++i] = ++j;
        } else {
            j = Next[j];
        }
    }
}

int KmpSearch(char* s, char* p)
{
	int i = 0;
	int j = 0;
	int sLen = strlen(s);
	int pLen = strlen(p);
	while (i < sLen && j < pLen)
	{
		//①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++    
		if (j == -1 || s[i] == p[j])
		{
			i++;
			j++;
		}
		else
		{
			//②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]    
			//next[j]即为j所对应的next值      
			j = Next[j];
		}
	}
	if (j == pLen)
		return i - j;
	else
		return -1;
}
```

# 线段树

#### 区间染色

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <vector>
using namespace std;
const int N = 8e4 + 5;
const int MAX = 8e4 + 1;
int color[N];
struct Node {
	int color, time;
}t[N<<1];
void build() {
	for(int i = 1; i < (N<<1); ++i)
		t[i].color = -1, t[i].time = 0;
}
void update(int l, int r, int color, int time) {
	for(l += MAX, r += MAX; l < r; l >>= 1, r >>= 1) {
		if(l&1)	t[l].color = color, t[l++].time = time;
		if(r&1)	t[--r].color = color, t[r].time = time;
	}
}
void push() {
	for(int i = 1; i < MAX; ++i) {
		if(t[i].time > t[i<<1].time)	t[i<<1].time = t[i].time, t[i<<1].color = t[i].color;
		if(t[i].time > t[i<<1|1].time)	t[i<<1|1].time = t[i].time, t[i<<1|1].color = t[i].color;
	}
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int m, l, r, c;
	while(cin >> m) {
		build();
		for(int i = 1; i <= m; ++i) {
			cin >> l >> r >> c;
			update(l, r, c, i);
		}
		push();
		memset(color, 0, sizeof(color));
		int now = -1;
		for(int i = 0 + MAX; i <= MAX + MAX; ++i) {
			if(now == -1) {
				if(t[i].color == -1)	continue;
				now = t[i].color;
			} else {
				if(t[i].color == now)	continue;
				else {
					color[now]++;
					now = t[i].color;
				}
			}
		}

		for(int i = 0; i < MAX; ++i)
			if(color[i])	cout << i << " " << color[i] << '\n';
		cout << '\n';
	}
}
```

#### 区间开根号

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <cmath>
#include <vector>
using namespace std;
const int MAX = 2e5 + 5;
struct Node {
	bool type;//if all values in this segment are '1'
	long long val;
}t[MAX];
int n, m;
void build() {
	for(int i = n - 1; i > 0; --i) {
		if(t[i<<1].type && t[i<<1|1].type)	t[i].type = 1;
		else	t[i].type = 0;
		t[i].val = t[i<<1].val + t[i<<1|1].val;
	}
}
void up(int x) {
	while(x > 1) {
		t[x>>1].val = t[x].val + t[x^1].val;
		x >>= 1;
	}
}
long long deal(int x) {
	if(t[x].type == 1)	return t[x].val;
	if(x >= n) {
//		cout << x << " " << t[x].val << " -> " << (int)sqrt(t[x].val) << endl;
		t[x].val = sqrt(t[x].val);
//		cout << "now : " << t[x].val << endl;
		if(t[x].val <= 1)	t[x].type = 1;
		up(x);
		return t[x].val;
	}
	if(t[x<<1].type != 1)	deal(x<<1);
	if(t[x<<1|1].type != 1)	deal(x<<1|1);

	t[x].val = t[x<<1].val + t[x<<1|1].val;
	if(t[x<<1].type && t[x<<1|1].type)	t[x].type = 1;
	up(x);
	return t[x].val;
}
void update(int l, int r) {
	for(l += n, r += n; l < r; l >>= 1, r >>= 1) {
		if(l&1) deal(l++);
		if(r&1)	deal(--r);
	}
}
long long query(int l, int r) {
	long long ans = 0;
	for(l += n, r += n; l < r; l >>= 1, r >>= 1) {
		if(l&1)	{
			ans += t[l++].val;
		}
		if(r&1)	{
			ans += t[--r].val;
		}
	}
	return ans;
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int cnt = 1;
	// freopen("input", "r", stdin);
	// freopen("output.a", "w", stdout);
	while(cin >> n) {
		cout << "Case #" << cnt++ << ":\n";
		for(int i = 0; i < n; ++i) {
			cin >> t[i + n].val;
			if(t[i + n].val <= 1)	t[i + n].type = 1;
			else	t[i + n].type = 0;
		}
		build();
		cin >> m;
		int type, l, r;
		while(m--) {
			cin >> type >> l >> r;
			if(l > r)	swap(l, r);
			if(type == 0)	update(l - 1, r);
			else	cout << query(l - 1, r) << '\n';
		}
		cout << '\n';
	}
}
```

### 懒惰标记

#### 递归版区间修改，求区间最大值

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
using namespace std;
struct Node {
	long val, lazy;
	int l, r;
	struct Node* L, *R;
};
const int MAX = 1e5 + 5;
long a[MAX];
int n;
long max(long a, long b) {
	if (a > b)	return a;
	return b;
}
void build(Node*& t, int l, int r) {
	t->l = l;
	t->r = r;
	t->lazy = 0;
	if (l == r) {
		t->val = a[l];
		return ;
	}

	t->L = (Node*)malloc(sizeof(Node));
	t->R = (Node*)malloc(sizeof(Node));
	int mid = (l + r) >> 1;
	build(t->L, l, mid);
	build(t->R, mid + 1, r);

	t->val = max(t->L->val, t->R->val);
}

void update(Node*& t, int l, int r, long add) {
	if(l == t->l && r == t->r) {
		t->val += add;
		t->lazy += add;
		return ;
	}

	int mid = (t->r + t->l) >> 1;
	if (r <= mid)	update(t->L, l, r, add);
	else if (l > mid)	update(t->R, l, r, add);
	else update(t->L, l, mid, add), update(t->R, mid + 1, r, add);

	//下面这一句不知道有没有加的必要
	//唔，应该是有的
	t->val = max(t->L->val, t->R->val) + t->lazy;
}

void push(Node*& t) {
	if (t->l == t->r)	return ;
	t->L->val += t->lazy;
	t->L->lazy += t->lazy;
	t->R->val += t->lazy;
	t->R->lazy += t->lazy;
	t->lazy = 0;
}

long query(Node*& t, int l, int r) {
	push(t);
	if (t->l == l && t->r == r) {
		return t->val;
	}

	int mid = (t->l + t->r) >> 1;
	if (r <= mid)	return query(t->L, l, r);
	else if (l > mid)	return query(t->R, l, r);
	else return max(query(t->L, l, mid), query(t->R, mid + 1, r));
}
Node* t;
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	t = (Node*)malloc(sizeof(Node));
	cin >> n;
	for (int i = 1; i <= n; ++i) cin >> a[i];
	build(t, 1, n);

	int type, l, r;
	long add;
	cin >> n;
	while (n--) {
		cin >> type >> l >> r;
		if (type == 2) cout << query(t, l, r) << '\n';
		else {
			cin >> add;
			update(t, l, r, add);
		}
	}
}
```

#### 线段树在线更新

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <string>
using namespace std;
const int MAX = 1e6 + 5;
struct Node {
	int l, r, Left, Right, ans;
	struct Node* L, * R;
};
char a[MAX];
void build(Node*& t, int l, int r) {
	t->l = l;
	t->r = r;
	t->Left = t->Right = t->ans = 0;
	if(l == r)	{
		if (a[t->l] == '(')	t->Left = 1;
		else	t->Right = 1;
		return ;
	}
	int mid = (l + r) >> 1;
	t->L = (Node*)malloc(sizeof(Node));
	t->R = (Node*)malloc(sizeof(Node));
	build(t->L, l, mid);
	build(t->R, mid + 1, r);

	int ans = min(t->L->Left, t->R->Right);
	t->ans = t->L->ans + t->R->ans + ans;
	t->Left = t->L->Left + t->R->Left - ans;
	t->Right = t->L->Right + t->R->Right - ans;
}

Node* query(Node* t, int l, int r) {
	//cout << l << " " << r << endl;
	if(l == t->l && r == t->r) {
		return t;
	}

	int mid = (t->l + t->r) >> 1;

	if (r <= mid) return query(t->L, l, r);
	else if (l > mid)	return query(t->R, l, r);
	else {
		//只有在这个时候才需要进行合并操作
		Node* temp = (Node*)malloc(sizeof(Node));
		Node* Left = query(t->L, l, mid), * Right = query(t->R, mid + 1, r);
		int ans = min(Left->Left, Right->Right);

		temp->ans = ans + Left->ans + Right->ans;
		temp->Left = Left->Left + Right->Left - ans;
		temp->Right = Left->Right + Right->Right - ans;
		return temp;
	}
}
Node* t, *temp;
int main() {
	scanf("%s", a);
	int len = strlen(a);

	t = (Node*)malloc(sizeof(Node));
	build(t, 0, len - 1);

	int m, l, r;
	scanf("%d", &m);
	while(m--) {
		scanf("%d%d", &l, &r);
		temp = query(t, l - 1, r - 1);
		printf("%d\n", temp->ans * 2);
	}
	return 0;
}
```

# 逆元 + 组合数

```c++
const int mod=1e9+7;
int extgcd(int a,int b,int &x,int &y){
    int d=a;
    if(b!=0){
        d=extgcd(b,a%b,y,x);
        y-=(a/b)*x;
    }
    else    x=1,y=0;
    return d;
}
int inv(int a){
    int x,y,d=extgcd(a,mod,x,y);
    x=(x%mod+mod)%mod;
    return x;
}
int fac[200005];

int fun(int a,int b){
    int x=inv((1LL*fac[b]*fac[a-b])%mod);
    return (1LL*fac[a]*x)%mod;
}
```

# 字符串实现减法

```c++
void deal(char *a, char *b) {//a is bigger than b
     for (int i = len - 1; i >= 0; --i) {
             if (a[i] >= b[i]) ans[i] = a[i] - b[i] + '0';
             else {
                 a[i] += 10;
                 if(a[i - 1] == '0')  a[i - 1] = '9';
                 else   a[i - 1]--;
                 ans[i] = a[i] - b[i] + '0';
             }
     }  
}
```



# 图论

### Trajan O(E + V)

#### 带环有向图缩点形成DAG

```c++
int number[MAX], head[MAX], cnt, low[MAX], s[MAX], top, scc, belong[MAX];
void dfs(int u) {
	number[u] = low[u] = ++cnt;
	int v;
	s[++top] = u;
	for (int i = head[u]; i; i = e[i].nex) {
		v = e[i].to;
		if (!number[v]) {
			dfs(v);
			low[u] = min(low[u], low[v]);
		} else if (!belong[v])	{
			low[u] = min(low[u], number[v]);
		}
	}

	int x;
	if (low[u] == number[u]) {
		++scc;
		while (true) {
			x = s[top--];
			belong[x] = scc;
			size[scc]++;
			if (x == u)	break;
		}
	}
}
void buildGraph() {
	cnt = 0;
	int v;
	for (int i = 1; i <= n; ++i) {
		for (int j = head[i]; j; j = e[j].nex) {
			v = e[j].to;
			if (belong[v] != belong[i])	add2(belong[i], belong[v]);
		}
	}
}
void trajan() {
	for (int i = 1; i <= n; ++i) {
    	if (!number[i])	dfs(i);
    }
}
```

#### 求割点

当一个点是割点，需要满足的两个条件

**1)** u is root of DFS tree and it has at least two children. 

**2)** u is not root of DFS tree and it has a child v such that no vertex in subtree rooted with v has a back edge to one of the ancestors (in DFS tree) of u.

```c++
void dfs(int u, int fa) {
	low[u] = number[u] = ++cnt;
	int v, child = 0;
	for (int i = head[u]; i; i = e[i].nex) {
		v = e[i].idx;
		if (!number[v]) {
			dfs(v, u);
			low[u] = min(low[u], low[v]);
			child++;
			if (low[v] >= number[u])	scc[u]++;
		} else if (number[v] < number[u] && v != fa) {
			low[u] = min(low[u], number[v]);
		}
	}

	if (child == 1 && fa == -1)	scc[u] = 0;
}
```

在该程序退出之后，如果scc[idx] != 0，那么该点就是割点

### Hungarian O(E$\cdot$V)

* 建图的时候只需要建立从左往右的点即可
* 在for循环中也只需要遍历左边的点即可
* 左右两边的点，对应的标记不可以相等

```c++
int match[MAX], vis[MAX];
bool dfs(int now) {
	vis[now] = 1;
	int v;
	for (int i = head[now]; i; i = e[i].nex) {
		v = e[i].to;
		if (match[v] == -1 || !vis[match[v]] && dfs(match[v])) {
			match[now] = v;
			match[v] = now;
			return true;
		}
	}
	return false;
}
int hungarian() {
	int ans = 0;
	memset(match, -1, sizeof(match));
	for (int i = 1; i <= n; ++i) {
		if (match[i] == -1) {
			memset(vis, 0, sizeof(vis)); // 可以使用技巧优化掉这个n
			if (dfs(i))	++ans;
		}
	}
	return ans;
}
```



# 注意事项

1. 读题！读题！读题！有没有地方是理解错了的！  (二进制  ->  十进制)
2. Debug  -> 看看有没有什么变量拼错了，搞成了另外一个变量 !!!
3. 链式前向星，注意开双倍大小!! 在二分图建模时可能会是平方大小!!!
4. 输出的格式对不对!!! "YES"  "NO"