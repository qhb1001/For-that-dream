# JAVA大数

#### 使用大整数的compareTo()函数

```java
import java.util.*;
import java.math.*;
import java.lang.*;
public class Main{
    public static void main(String[] args) {
        Scanner cin = new Scanner(System.in);
        BigInteger []ans = new BigInteger[2005];
        ans[1] = BigInteger.ONE;
        ans[2] = BigInteger.ONE.add(ans[1]);
        for(int i = 3; i < 2000; ++i){
            ans[i] = ans[i - 1].add(ans[i - 2]);
            if(ans[i].toString().length() > 100)   {
                break;
            }
        }
        BigInteger a, b;
        while(true) {
            a = cin.nextBigInteger();
            b = cin.nextBigInteger();
            if(a.compareTo(BigInteger.ZERO) == 0 && b.compareTo(BigInteger.ZERO) == 0) break;
            int c = 0;
            for(int i = 1; i <= 480; ++i)
                if(a.compareTo(ans[i]) <= 0 && ans[i].compareTo(b) <= 0) ++c;
            System.out.println(c);
        }
    }
}
```

#### 使用大浮点数的内建方法

```java
import java.util.*;
import java.math.*;
import java.lang.*;
public class Main{
    public static void main(String[] args) {
        BigDecimal ans;
        int n;
        Scanner cin = new Scanner(System.in);
        while(cin.hasNext()) {
            ans = cin.nextBigDecimal();
            n = cin.nextInt();
            String a = ans.pow(n).stripTrailingZeros().toPlainString();//去除末尾多余的零
            while(a.charAt(0) == '0')  a = a.substring(1);
            System.out.println(a);
        }
    }
}
```

### 大数乘除

```java
import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.math.BigInteger;
import java.util.Scanner;

public class Main {
	public static void main(String[] args) throws FileNotFoundException {
		Scanner cin = new Scanner(new File("input.txt"));
		PrintWriter print = new PrintWriter(new File("output.txt"));
		int n;
		BigInteger []t = new BigInteger[307];
		BigInteger []num = new BigInteger[307];
		num[3] = BigInteger.valueOf(2);
		num[6] = BigInteger.valueOf(9);
		t[12] = BigInteger.valueOf(17);
		num[9] = BigInteger.valueOf(38);
		for(int i = 12;i<=300;i+=3){
			if((i%2)==0){
				num[i] = num[i-3].multiply(BigInteger.valueOf(4)).subtract(t[i]);
				t[i+6] = t[i].multiply(BigInteger.valueOf(4)).add(BigInteger.valueOf(21));
			}else {
				num[i] = num[i-3].multiply(BigInteger.valueOf(4)).add(BigInteger.valueOf(2));
			}
		}
		while(cin.hasNext()){
			n = cin.nextInt();
			print.println(num[n]);
		}
		cin.close();
		print.close();
	}
}
```



# 矩阵模板(注意在需要的地方改long long)

```c++
struct Mat{
    int row, col ,N[25][25];
    Mat(int row = 0 , int col = 0){
        memset(N, 0, sizeof(N));
        this -> row = row;
        this -> col = col;
    }
    Mat operator * (const Mat B) const {
        Mat A(row, B.col);
        for(int i = 0 ;i < row; i ++)
            for(int k = 0 ; k < col; k ++)
                for(int j = 0 ; j < B.col; j++){
                    A.N[i][j] = A.N[i][j] + N[i][k] * B.N[k][j] ;
                }
        return A;
    }
    Mat operator ^ (int x) const {
        Mat A(row,row) , temp = *this;
        for(int i = 0 ; i < row; i ++)  A.N[i][i] = 1;
        while(x){
            if(x & 1)   A = A * temp;
            temp = temp * temp;
            x>>= 1;
        }
        return A;
    }
};
```

# KMP

```c++
void getNext(string &a) {
    int i = 0, j = -1, len = a.size();
    Next[0] = -1;
    while(i < len) {
        if(j == -1 || a[i] == a[j]) {
            Next[++i] = ++j;
        } else {
            j = Next[j];
        }
    }
}

int KmpSearch(char* s, char* p)
{
	int i = 0;
	int j = 0;
	int sLen = strlen(s);
	int pLen = strlen(p);
	while (i < sLen && j < pLen)
	{
		//①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++    
		if (j == -1 || s[i] == p[j])
		{
			i++;
			j++;
		}
		else
		{
			//②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]    
			//next[j]即为j所对应的next值      
			j = Next[j];
		}
	}
	if (j == pLen)
		return i - j;
	else
		return -1;
}
```

# 线段树

#### 区间染色

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <vector>
using namespace std;
const int N = 8e4 + 5;
const int MAX = 8e4 + 1;
int color[N];
struct Node {
	int color, time;
}t[N<<1];
void build() {
	for(int i = 1; i < (N<<1); ++i)
		t[i].color = -1, t[i].time = 0;
}
void update(int l, int r, int color, int time) {
	for(l += MAX, r += MAX; l < r; l >>= 1, r >>= 1) {
		if(l&1)	t[l].color = color, t[l++].time = time;
		if(r&1)	t[--r].color = color, t[r].time = time;
	}
}
void push() {
	for(int i = 1; i < MAX; ++i) {
		if(t[i].time > t[i<<1].time)	t[i<<1].time = t[i].time, t[i<<1].color = t[i].color;
		if(t[i].time > t[i<<1|1].time)	t[i<<1|1].time = t[i].time, t[i<<1|1].color = t[i].color;
	}
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int m, l, r, c;
	while(cin >> m) {
		build();
		for(int i = 1; i <= m; ++i) {
			cin >> l >> r >> c;
			update(l, r, c, i);
		}
		push();
		memset(color, 0, sizeof(color));
		int now = -1;
		for(int i = 0 + MAX; i <= MAX + MAX; ++i) {
			if(now == -1) {
				if(t[i].color == -1)	continue;
				now = t[i].color;
			} else {
				if(t[i].color == now)	continue;
				else {
					color[now]++;
					now = t[i].color;
				}
			}
		}

		for(int i = 0; i < MAX; ++i)
			if(color[i])	cout << i << " " << color[i] << '\n';
		cout << '\n';
	}
}
```

#### 懒惰标记

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <cmath>
#include <vector>
using namespace std;
const int MAX = 2e5 + 5;
struct Node {
	bool type;//if all values in this segment are '1'
	long long val;
}t[MAX];
int n, m;
void build() {
	for(int i = n - 1; i > 0; --i) {
		if(t[i<<1].type && t[i<<1|1].type)	t[i].type = 1;
		else	t[i].type = 0;
		t[i].val = t[i<<1].val + t[i<<1|1].val;
	}
}
void up(int x) {
	while(x > 1) {
		t[x>>1].val = t[x].val + t[x^1].val;
		x >>= 1;
	}
}
long long deal(int x) {
	if(t[x].type == 1)	return t[x].val;
	if(x >= n) {
//		cout << x << " " << t[x].val << " -> " << (int)sqrt(t[x].val) << endl;
		t[x].val = sqrt(t[x].val);
//		cout << "now : " << t[x].val << endl;
		if(t[x].val <= 1)	t[x].type = 1;
		up(x);
		return t[x].val;
	}
	if(t[x<<1].type != 1)	deal(x<<1);
	if(t[x<<1|1].type != 1)	deal(x<<1|1);

	t[x].val = t[x<<1].val + t[x<<1|1].val;
	if(t[x<<1].type && t[x<<1|1].type)	t[x].type = 1;
	up(x);
	return t[x].val;
}
void update(int l, int r) {
	for(l += n, r += n; l < r; l >>= 1, r >>= 1) {
		if(l&1) deal(l++);
		if(r&1)	deal(--r);
	}
}
long long query(int l, int r) {
	long long ans = 0;
	for(l += n, r += n; l < r; l >>= 1, r >>= 1) {
		if(l&1)	{
			ans += t[l++].val;
		}
		if(r&1)	{
			ans += t[--r].val;
		}
	}
	return ans;
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int cnt = 1;
	// freopen("input", "r", stdin);
	// freopen("output.a", "w", stdout);
	while(cin >> n) {
		cout << "Case #" << cnt++ << ":\n";
		for(int i = 0; i < n; ++i) {
			cin >> t[i + n].val;
			if(t[i + n].val <= 1)	t[i + n].type = 1;
			else	t[i + n].type = 0;
		}
		build();
		cin >> m;
		int type, l, r;
		while(m--) {
			cin >> type >> l >> r;
			if(l > r)	swap(l, r);
			if(type == 0)	update(l - 1, r);
			else	cout << query(l - 1, r) << '\n';
		}
		cout << '\n';
	}
}
```

# 逆元 + 组合数

```c++
const int mod=1e9+7;
int extgcd(int a,int b,int &x,int &y){
    int d=a;
    if(b!=0){
        d=extgcd(b,a%b,y,x);
        y-=(a/b)*x;
    }
    else    x=1,y=0;
    return d;
}
int inv(int a){
    int x,y,d=extgcd(a,mod,x,y);
    x=(x%mod+mod)%mod;
    return x;
}
int fac[200005];

int fun(int a,int b){
    int x=inv((1LL*fac[b]*fac[a-b])%mod);
    return (1LL*fac[a]*x)%mod;
}
```

# Cantour

```c++
int fac[]={1,1,2,6,24,120,720,5040,40320,362880};
int cantor(string s){
    int temp,num;
    num=0;
    for(int i=0;i<n-1;i++){//n为位数
        temp=0;
        for(int j=i+1;j<n;j++){
            if(s[j]<s[i]) temp++;
        }
        num+=fac[n-i-1]*temp;
    }
    return (num+1);
}

void getstr(int val){
    int tmp[10],flag[10];
    memset(flag,0,sizeof flag);
    for(int i=0;i<9;i++) tmp[i]=val/c[8-i],val=val%c[8-i];
    for(int i=0;i<9;i++){
        int num=0;
        for(int j=0;j<9;j++){
            if(flag[j]==0) num++;
            if(num==tmp[i]+1){
                t[i]=j+'0'+1; if(t[i]=='9') t[i]='x';
                flag[j]=1;break;
            }
        }
    }
}

```

# Tarjan

```c++
//  求解有向图的强链接分量的线性算法,以及需加入最少条数，使之为强连通图
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <stack>
#include <algorithm>
using namespace std;

const int maxn=1e4+10;
int n,m;
int _in,_out;
int flag[maxn];
vector<int>edge[maxn];
stack<int>s;
int dfn[maxn],low[maxn];
int num,cnt;
int in[maxn],out[maxn];

void dfs(int u){
    dfn[u]=low[u]=++num;
    s.push(u);
    for(int i=(edge[u].size()-1);i>=0;i--){
        int v=edge[u][i];
        if(!dfn[v]){
            dfs(v);
            if(low[v]<low[u])
                low[u]=low[v];
        }
        else if(!flag[v]&&dfn[v]<low[u]){
            low[u]=dfn[v];
        }
    }
    if(low[u]==dfn[u]){
        cnt++;//连通图的个数
        while(true){
            int v=s.top();
            s.pop();
            flag[v]=cnt;
            if(v==u) break;
        }
    }
    return ;
}

void Tarjan(){
    memset(flag,0,sizeof(flag));
    memset(dfn,0,sizeof(dfn));
    memset(low,0,sizeof(low));
    memset(in,0,sizeof(in));
    memset(out,0,sizeof(out));
    num=0;cnt=0;_in=0;_out=0;
    
    for(int i=1;i<=n;i++){
        if(!dfn[i]) dfs(i);
    }
    
    return ;
}

void add_edge(){
    for(int i=1;i<=n;i++){
        for(int j=(edge[i].size()-1);j>=0;j--){
            if(flag[i]!=flag[edge[i][j]])
                ++out[flag[i]],++in[flag[edge[i][j]]];
        }
    }
    for(int i=1;i<=cnt;i++){
        if(!in[i]) _in++;
        if(!out[i]) _out++;
    }
}

int main(){
    int T;
    scanf("%d",&T);
    while(T--){
        scanf("%d %d",&n,&m);
        for(int i=1;i<=n;i++)
            edge[i].clear();
        for(int i=0;i<m;i++){
            int u,v;
            scanf("%d %d",&u,&v);
            edge[u].push_back(v);
        }
        Tarjan();
        cout<<cnt<<endl;
        if(cnt==1)puts("0");
        else{
            add_edge();
            int ans=max(_in,_out);
            printf("%d\n",ans);
        }
    }
    return 0;
}
```

# 并查集

```js
int f[3*maxn],cnt[3*maxn];
int n;
void Init(){
    for(int i=1;i<=n;i++){
        f[i]=i;f[maxn+i]=maxn+i;f[2*maxn+i]=2*maxn+i;
        cnt[i]=cnt[maxn+i]=cnt[2*maxn+i]=1;
    }
}

int Find(int x){
    if(x!=f[x]){
        f[x]=Find(f[x]);
    }
    return f[x];
}

void Union(int x,int y){
    int a=Find(x),b=Find(y);
    if(a==b) return ;
    if(cnt[a]<cnt[b]){
        f[a]=b;
        cnt[a]+=cnt[b];
    }
    else{
        f[b]=a;
        cnt[b]+=cnt[a];
    }
}

```

# 最短路

```c++
//Dijkstra（无负边时的最短路问题） 
const int INF=0x3f3f3f3f;
const int N=1e5+10;

vector < pair<int,int> > E[N];
int n,m;
int d[N];
bool vis[N];

void init(){
    memset(vis,0,sizeof(vis));
    for(int i=0;i<N;i++) d[i]=INF;
    for(int i=0;i<N;i++) E[i].clear();
}

void dijkstra(int s,int d[]){
    priority_queue < pair<int,int> > Q;
    d[s]=0;
    Q.push(make_pair(-d[s],s));
    
    while(!Q.empty()){
        int now=Q.top().second;
        Q.pop();
        if(vis[now]) continue;
        vis[now]=1;
        for(int i=0;i<E[now].size();i++){
            int v=E[now][i].first;
            int D=d[now]+E[now][i].second;
            if(d[v]>D){
                d[v]=D;
                Q.push(make_pair(-d[v],v));
            }
        }
    }
}
```

# 最小生成树

```c++
const int N=1e5+10;
vector < pair<int,int> > E[N];
bool vis[N];

void init(){
    memset(vis,0,sizeof(vis));
    for(int i=0;i<N;i++) E[i].clear();
}

//起点为1
int prim(){
    int res=0;
    priority_queue < pair<int,int> > Q;
    for(int i=0;i<E[1].size();i++){
        int u=E[1][i].first;
        int d=E[1][i].second;
        Q.push(make_pair(-d,u));
    }
    vis[1]=1;
    while(!Q.empty()){
        int now=Q.top().second;
        int D=Q.top().first;
        Q.pop();
        if(vis[now]) continue;
        vis[now]=1;
        res=res+(-D);
        for(int i=0;i<E[now].size();i++){
            int u=E[now][i].first;
            int d=E[now][i].second;
            Q.push(make_pair(-d,u));
        }
    }
    return res;
}
```

### 数学

#### 费马小定理

```c++
gcd(a,p)=1,那么a^(p-1)==1(mod p)
mypow(a,k*(mod-2)) = mypow(a,k*(mod-2)%(mod-1));
```

#### 

