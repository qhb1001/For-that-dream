[TOC]

# JAVA大数

### 使用大整数的compareTo()函数

```java
import java.util.*;
import java.math.*;
import java.lang.*;
public class Main{
    public static void main(String[] args) {
        Scanner cin = new Scanner(System.in);
        BigInteger []ans = new BigInteger[2005];
        ans[1] = BigInteger.ONE;
        ans[2] = BigInteger.ONE.add(ans[1]);
        for(int i = 3; i < 2000; ++i){
            ans[i] = ans[i - 1].add(ans[i - 2]);
            if(ans[i].toString().length() > 100)   {
                break;
            }
        }
        BigInteger a, b;
        while(true) {
            a = cin.nextBigInteger();
            b = cin.nextBigInteger();
            if(a.compareTo(BigInteger.ZERO) == 0 && b.compareTo(BigInteger.ZERO) == 0) break;
            int c = 0;
            for(int i = 1; i <= 480; ++i)
                if(a.compareTo(ans[i]) <= 0 && ans[i].compareTo(b) <= 0) ++c;
            System.out.println(c);
        }
    }
}
```

### 使用大浮点数的内建方法

```java
import java.util.*;
import java.math.*;
import java.lang.*;
public class Main{
    public static void main(String[] args) {
        BigDecimal ans;
        int n;
        Scanner cin = new Scanner(System.in);
        while(cin.hasNext()) {
            ans = cin.nextBigDecimal();
            n = cin.nextInt();
            String a = ans.pow(n).stripTrailingZeros().toPlainString();//去除末尾多余的零
            while(a.charAt(0) == '0')  a = a.substring(1);
            System.out.println(a);
        }
    }
}
```

### 使用自带的Miller Rabin方法

```java
public class Main {
    public static void main(String[] args) {
        InputReader reader = new InputReader();
        PrintWriter out = new PrintWriter(System.out);
        int t = reader.nextInt();
        while (t-- > 0) {
            long n = reader.nextLong();
            long half = n / 2;
            int get = (int) (half % 10);
            // if (isPrime(n - 5)) {
            // if (Miller_Rabin(n - 5)) {
            if (BigInteger.valueOf(n - 5).isProbablePrime(5)) {
                out.println(5 + " " + (n - 5));
                continue;
            }
            while (half > 0) {
                // System.out.println(half);
                if (get == 1 || get == 7 || get == 9 || get == 3) {
                    // if (isPrime(get)) {
                    // if (Miller_Rabin(half)) {
                    if (BigInteger.valueOf(half).isProbablePrime(5)) {
                        long half2 = n - half;
                        long get2 = half2 % 10;
                        if (get2 == 1 || get2 == 7 || get2 == 9 || get2 == 3) {
                            // if (isPrime(half2)) {
                            // if (Miller_Rabin(half2)) {
                            if (BigInteger.valueOf(half2).isProbablePrime(5)) {
                                out.println(half + " " + half2);
                                break;
                            }
                        }
                    }
                }
                half--;
                get = (int) (half % 10);
            }
        }
        out.close();
    }
}
```



### 大数乘除

```java
import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.math.BigInteger;
import java.util.Scanner;

public class Main {
	public static void main(String[] args) throws FileNotFoundException {
		Scanner cin = new Scanner(new File("input.txt"));
		PrintWriter print = new PrintWriter(new File("output.txt"));
		int n;
		BigInteger []t = new BigInteger[307];
		BigInteger []num = new BigInteger[307];
		num[3] = BigInteger.valueOf(2);
		num[6] = BigInteger.valueOf(9);
		t[12] = BigInteger.valueOf(17);
		num[9] = BigInteger.valueOf(38);
		for(int i = 12;i<=300;i+=3){
			if((i%2)==0){
				num[i] = num[i-3].multiply(BigInteger.valueOf(4)).subtract(t[i]);
				t[i+6] = t[i].multiply(BigInteger.valueOf(4)).add(BigInteger.valueOf(21));
			}else {
				num[i] = num[i-3].multiply(BigInteger.valueOf(4)).add(BigInteger.valueOf(2));
			}
		}
		while(cin.hasNext()){
			n = cin.nextInt();
			print.println(num[n]);
		}
		cin.close();
		print.close();
	}
}
```

### 使用String初始化BigInteger

```java
BigInteger now = new BigInteger("100000");
```



# 矩阵模板

注意，对矩阵的最大容量应该限制得尽量小

如果存在大量的乘法以及快速幂，那么会导致申请了很多个矩阵，也就是很多个memset()

```c++
struct Mat{
    int row, col, N[25][25];
    Mat(int row = 0 , int col = 0){
        memset(N, 0, sizeof(N));
        this -> row = row;
        this -> col = col;
    }
    Mat operator * (const Mat B) const {
        Mat A(row, B.col);
        for(int i = 0 ;i < row; i ++)
            for(int k = 0 ; k < col; k ++)
                for(int j = 0 ; j < B.col; j++){
                    A.N[i][j] = (A.N[i][j] + (ll)N[i][k] * B.N[k][j] + mod) % mod;
                }
        return A;
    }
    Mat operator ^ (int x) const {
        Mat A(row,row) , temp = *this;
        for(int i = 0 ; i < row; i ++)  A.N[i][i] = 1;
        while(x){
            if(x & 1)   A = A * temp;
            temp = temp * temp;
            x >>= 1;
        }
        return A;
    }
};
```

# KMP

```c++
void getNext(string &a) {
    int i = 0, j = -1, len = a.size();
    Next[0] = -1;
    while(i < len) {
        if(j == -1 || a[i] == a[j]) {
            Next[++i] = ++j;
        } else {
            j = Next[j];
        }
    }
}

int KmpSearch(char* s, char* p)
{
	int i = 0;
	int j = 0;
	int sLen = strlen(s);
	int pLen = strlen(p);
	while (i < sLen && j < pLen)
	{
		//①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++    
		if (j == -1 || s[i] == p[j])
		{
			i++;
			j++;
		}
		else
		{
			//②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]    
			//next[j]即为j所对应的next值      
			j = Next[j];
		}
	}
	if (j == pLen)
		return i - j;
	else
		return -1;
}
```

# 递归版线段树

注意的几个地方

* 数组的容量应该开成最大容量的四倍，即`MAX<<2`
* 在需要对线段树中的所有元素进行遍历时，可以在`query`函数中对区间进行操作，将会减小常数
* 懒惰标记的关键是`push()` & `up()`，在`update()` & `query()`里面都需要如此设置

### 区间染色

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <vector>
using namespace std;
const int N = 8e4 + 5;
const int MAX = 8e4 + 1;
int color[N];
struct Node {
	int color, time;
}t[N<<1];
void build() {
	for(int i = 1; i < (N<<1); ++i)
		t[i].color = -1, t[i].time = 0;
}
void update(int l, int r, int color, int time) {
	for(l += MAX, r += MAX; l < r; l >>= 1, r >>= 1) {
		if(l&1)	t[l].color = color, t[l++].time = time;
		if(r&1)	t[--r].color = color, t[r].time = time;
	}
}
void push() {
	for(int i = 1; i < MAX; ++i) {
		if(t[i].time > t[i<<1].time)	t[i<<1].time = t[i].time, t[i<<1].color = t[i].color;
		if(t[i].time > t[i<<1|1].time)	t[i<<1|1].time = t[i].time, t[i<<1|1].color = t[i].color;
	}
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int m, l, r, c;
	while(cin >> m) {
		build();
		for(int i = 1; i <= m; ++i) {
			cin >> l >> r >> c;
			update(l, r, c, i);
		}
		push();
		memset(color, 0, sizeof(color));
		int now = -1;
		for(int i = 0 + MAX; i <= MAX + MAX; ++i) {
			if(now == -1) {
				if(t[i].color == -1)	continue;
				now = t[i].color;
			} else {
				if(t[i].color == now)	continue;
				else {
					color[now]++;
					now = t[i].color;
				}
			}
		}

		for(int i = 0; i < MAX; ++i)
			if(color[i])	cout << i << " " << color[i] << '\n';
		cout << '\n';
	}
}
```

### 懒惰标记

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <cmath>
#include <vector>
using namespace std;
const int MAX = 2e5 + 5;
struct Node {
	bool type;//if all values in this segment are '1'
	long long val;
}t[MAX];
int n, m;
void build() {
	for(int i = n - 1; i > 0; --i) {
		if(t[i<<1].type && t[i<<1|1].type)	t[i].type = 1;
		else	t[i].type = 0;
		t[i].val = t[i<<1].val + t[i<<1|1].val;
	}
}
void up(int x) {
	while(x > 1) {
		t[x>>1].val = t[x].val + t[x^1].val;
		x >>= 1;
	}
}
long long deal(int x) {
	if(t[x].type == 1)	return t[x].val;
	if(x >= n) {
//		cout << x << " " << t[x].val << " -> " << (int)sqrt(t[x].val) << endl;
		t[x].val = sqrt(t[x].val);
//		cout << "now : " << t[x].val << endl;
		if(t[x].val <= 1)	t[x].type = 1;
		up(x);
		return t[x].val;
	}
	if(t[x<<1].type != 1)	deal(x<<1);
	if(t[x<<1|1].type != 1)	deal(x<<1|1);

	t[x].val = t[x<<1].val + t[x<<1|1].val;
	if(t[x<<1].type && t[x<<1|1].type)	t[x].type = 1;
	up(x);
	return t[x].val;
}
void update(int l, int r) {
	for(l += n, r += n; l < r; l >>= 1, r >>= 1) {
		if(l&1) deal(l++);
		if(r&1)	deal(--r);
	}
}
long long query(int l, int r) {
	long long ans = 0;
	for(l += n, r += n; l < r; l >>= 1, r >>= 1) {
		if(l&1)	{
			ans += t[l++].val;
		}
		if(r&1)	{
			ans += t[--r].val;
		}
	}
	return ans;
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int cnt = 1;
	// freopen("input", "r", stdin);
	// freopen("output.a", "w", stdout);
	while(cin >> n) {
		cout << "Case #" << cnt++ << ":\n";
		for(int i = 0; i < n; ++i) {
			cin >> t[i + n].val;
			if(t[i + n].val <= 1)	t[i + n].type = 1;
			else	t[i + n].type = 0;
		}
		build();
		cin >> m;
		int type, l, r;
		while(m--) {
			cin >> type >> l >> r;
			if(l > r)	swap(l, r);
			if(type == 0)	update(l - 1, r);
			else	cout << query(l - 1, r) << '\n';
		}
		cout << '\n';
	}
}
```



### 矩形周长并

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;
const int MAX = 2e4 + 5;

struct Edge1 {
    int x, y1, y2, type;
    Edge1(int a = 0, int b = 0, int c = 0, int d = 0): x(a), y1(b), y2(c), type(d) {}
    bool operator < (const Edge1 b) const {
        if (x != b.x)   return x < b.x;
        return type > b.type;
    }
};
struct Edge2 {
    int y, x1, x2, type;
    Edge2(int a = 0, int b = 0, int c = 0, int d = 0): y(a), x1(b), x2(c), type(d) {}
    bool operator < (const Edge2 b) const {
        if (y != b.y)   return y < b.y;
        return type > b.type;
    }
};
struct Node {
    int l, r, len, times;
}t[MAX<<2];
void build(int i, int l, int r) {
    t[i].l = l; t[i].r = r; t[i].len = t[i].times = 0;
    if (l == r) return ;
    int mid = l + r >> 1;
    build(i<<1, l, mid); build(i<<1|1, mid + 1, r);
}
void up(int i) {
    if (t[i].times) t[i].len = t[i].r - t[i].l + 1;
    else if (t[i].l == t[i].r)  t[i].len = 0;
    else t[i].len = t[i<<1].len + t[i<<1|1].len;
}
void update(int i, int l, int r, int val) {
    // cout << t[i].l << ' ' << t[i].r << ' ' << l << ' ' << r << endl;
    if (t[i].l == l && t[i].r == r) {
        t[i].times += val;
        up(i);
        return ;
    }
    int mid = t[i].l + t[i].r >> 1;
    if (r <= mid)   update(i<<1, l, r, val);
    else if (l > mid)   update(i<<1|1, l, r, val);
    else {
        update(i<<1, l, mid, val);
        update(i<<1|1, mid + 1, r, val);
    }
    up(i);
}
int n, minX, minY, maxX, maxY, ans;
vector<Edge1>e1;
vector<Edge2>e2;
void input() {
    e1.clear(); e2.clear();
    int x1, x2, y1, y2;
    minX = 1<<30; minY = 1<<30;
    maxX = -(1<<30); maxY = -(1<<30);
    for (int i = 1; i <= n; ++i) {
        scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
        // x1 += 10001; x2 += 10001; y1 += 10001; y2 += 10001;
        e1.push_back(Edge1(x1, y1, y2, 1));
        e1.push_back(Edge1(x2, y1, y2, -1));
        e2.push_back(Edge2(y1, x1, x2, 1));
        e2.push_back(Edge2(y2, x1, x2, -1));
        minX = min(minX, x1);
        minY = min(minY, y1);
        maxX = max(maxX, x2);
        maxY = max(maxY, y2);
    }
    sort(e1.begin(), e1.end());
    sort(e2.begin(), e2.end());
    n *= 2;
}

void deal() {
    ans = 0;
    int last = 0, now = 0;
    build(1, 1, maxY - minY + 1);
    for (int i = 0; i < n; ++i) {
        update(1, e1[i].y1 - minY + 1, e1[i].y2 - minY, e1[i].type);
        last = now;
        now = t[1].len;
        ans += abs(now - last);
        // cout << now << endl;
    }

    last = 0; now = 0;
    build(1, 1, maxX - minX + 1);
    for (int i = 0; i < n; ++i) {
        update(1, e2[i].x1 - minX + 1, e2[i].x2 - minX, e2[i].type);
        last = now;
        now = t[1].len;
        ans += abs(now - last);

    }
}
int main() {
    // freopen("input.txt", "r", stdin);
    while (scanf("%d", &n) != EOF) {
        if (n == 0) {
            printf("0\n");
            continue;
        }
        input();
        deal();
        printf("%d\n", ans);
    }
}
```



### 矩形面积并

大体上的思路同周长并；线段树中的每一个结点保存一个线段，而不是点；因此在update中传入的上边界减一；离散化之后得到对应的边长比较tricky，在使用的时候需要将上标加一

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <algorithm>
#include <vector>
#include <map>
using namespace std;
const int MAX = 1e5 + 5;
struct Node {
    int l, r, times;
    double len;
}t[MAX<<3];
void build(int i, int l, int r) {
    t[i].l = l; t[i].r = r; t[i].len = t[i].times = 0;
    if (l == r) return ;
    int mid = (l + r) >> 1;
    build(i<<1, l, mid); build(i<<1|1, mid + 1, r);
}
struct Edge {
    double x, y1, y2;
    int val;
    Edge(double _1 = 0, double _2 = 0, double _3 = 0, int _4 = 0): x(_1), y1(_2), y2(_3), val(_4) {}
    bool operator < (const Edge b) const {
        if (x != b.x)   return x < b.x;
        return val > b.val;
    }
};
vector<Edge>e;
map<double, int>mp;
vector<double>temp;
int Max;
double a[MAX];
void preTreatment() {
    sort(temp.begin(), temp.end());
    mp[temp[0]] = 1;
    a[1] = temp[0];
    int len = temp.size(), cnt = 1;
    for (int i = 1; i < len; ++i) {
        if (temp[i] == temp[i - 1]) continue;
        else    mp[temp[i]] = ++cnt, a[cnt] = temp[i];
    }
    Max = cnt;
}
void up(int i) {
    if (t[i].times) t[i].len = a[t[i].r + 1] - a[t[i].l];
    else if (t[i].l == t[i].r)  t[i].len = 0;
    else    t[i].len = t[i<<1].len + t[i<<1|1].len;
}
void update(int i, int l, int r, int val) {
    if (t[i].l == l && t[i].r == r) {
        t[i].times += val;
        up(i);
        return ;
    }
    int mid = t[i].l + t[i].r >> 1;
    if (r <= mid)   update(i<<1, l, r, val);
    else if (l > mid)   update(i<<1|1, l, r, val);
    else {
        update(i<<1, l, mid, val);
        update(i<<1|1, mid + 1, r, val);
    }
    up(i);
}

int main() {
    // freopen("input.txt", "r", stdin);
    int n, cnt = 1;
    while (scanf("%d", &n) && n) {
        double x1, x2, y1, y2;
        e.clear(); temp.clear();
        for (int i = 1; i <= n; ++i) {
            scanf("%lf%lf%lf%lf", &x1, &y1, &x2, &y2);
            temp.push_back(y1); temp.push_back(y2);
            e.push_back(Edge(x1, y1, y2, 1));
            e.push_back(Edge(x2, y1, y2, -1));
        }
        sort(e.begin(), e.end());
        preTreatment();
        build(1, 1, Max + 1);
        double ans = 0, now = 0, x;
        for (int i = 0; i < 2*n; ++i) {
            ans += now * (e[i].x - x);
            // cout << mp[e[i].y1] << ' ' << mp[e[i].y2] << endl;
            update(1, mp[e[i].y1], mp[e[i].y2] - 1, e[i].val);
            now = t[1].len;
            x = e[i].x;
            // cout << now << endl;

        }
        printf("Test case #%d\nTotal explored area: %.2lf\n\n", cnt++, ans);
    }
}
```



# zkw线段树

### 在线更新

```c++
#include <iostream>
#include <cstring>
#include <string>
#include <cstdio>
using namespace std;
string s;
const int MAX = 1e6 + 5;
struct Node {
	int l, r, ans;
	Node(int a = 0, int b = 0, int c = 0): l(a), r(b), ans(c) {}
}t[MAX * 2];
int n;
Node combine(Node& a, Node& b) {
	int add = min(a.l, b.r);
	return Node(a.l - add + b.l, b.r - add + a.r, a.ans + b.ans + add); 
}
void build(int n) {
	for (int i = n - 1; i > 0; --i)
		t[i] = combine(t[i<<1], t[i<<1|1]);
}
Node query(int l, int r) {
	Node L, R;
	for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
		if (l&1)	L = combine(L, t[l++]);
		if (r&1)	R = combine(t[--r], R);
	}
	return combine(L, R);
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> s;
	n = s.size();
	for (int i = 0; i < n; ++i) {
		if (s[i] == '(')
			t[i + n] = Node(1, 0, 0);
		else	
			t[i + n] = Node(0, 1, 0);
	}
	build(n);

	int k, l, r;
	Node ans;
	cin >> k;
	while (k--) {
		cin >> l >> r;
		ans = query(l - 1, r);
		cout << ans.ans * 2 << '\n';
	}
}
```

### 求逆序对

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
const int MAX = 1e6 + 5;
int t[MAX<<1], n;
void update(int x) {
	for (t[x += n]++; x > 1; x >>= 1) {
		t[x>>1] = t[x] + t[x^1];
	}
}
int query(int l, int r) {
	int ans = 0;
	for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
		if (l&1)	ans += t[l++];
		if (r&1)	ans += t[--r];
	}
	return ans;
}

int a[MAX];
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n;
	for (int i = 1; i <= n; ++i)	cin >> a[i];
	long long ans = 0;
	for (int i = 1; i <= n; ++i) {
		if (a[i] != n)	ans += query(a[i] + 1, n + 1);
		// cout << ans << endl;
		update(a[i]);
	}

	// cout << ans << endl;

	if (n&1) {
		if (ans&1)	cout << "Petr";
		else	cout << "Um_nik";
	} else {
		if (ans&1)	cout << "Um_nik";
		else	cout << "Petr";
	}
	return 0;
}
```



# 逆元 + 组合数

```c++
const int mod=1e9+7;
int extgcd(int a,int b,int &x,int &y){
    int d=a;
    if(b!=0){
        d=extgcd(b,a%b,y,x);
        y-=(a/b)*x;
    }
    else    x=1,y=0;
    return d;
}
int inv(int a){
    int x,y,d=extgcd(a,mod,x,y);
    x=(x%mod+mod)%mod;
    return x;
}
int fac[200005];

int fun(int a,int b){
    int x=inv((1LL*fac[b]*fac[a-b])%mod);
    return (1LL*fac[a]*x)%mod;
}
```

# 最短路

```c++
//Dijkstra（无负边时的最短路问题） 
const int INF=0x3f3f3f3f;
const int N=1e5+10;

vector < pair<int,int> > E[N];
int n,m;
int d[N];
bool vis[N];

void init(){
    memset(vis,0,sizeof(vis));
    for(int i=0;i<N;i++) d[i]=INF;
    for(int i=0;i<N;i++) E[i].clear();
}

void dijkstra(int s,int d[]){
    priority_queue < pair<int,int> > Q;
    d[s]=0;
    Q.push(make_pair(-d[s],s));
    
    while(!Q.empty()){
        int now=Q.top().second;
        Q.pop();
        if(vis[now]) continue;
        vis[now]=1;
        for(int i=0;i<E[now].size();i++){
            int v=E[now][i].first;
            int D=d[now]+E[now][i].second;
            if(d[v]>D){
                d[v]=D;
                Q.push(make_pair(-d[v],v));
            }
        }
    }
}
```

# 最小生成树

```c++
const int N=1e5+10;
vector < pair<int,int> > E[N];
bool vis[N];

void init(){
    memset(vis,0,sizeof(vis));
    for(int i=0;i<N;i++) E[i].clear();
}

//起点为1
int prim(){
    int res=0;
    priority_queue < pair<int,int> > Q;
    for(int i=0;i<E[1].size();i++){
        int u=E[1][i].first;
        int d=E[1][i].second;
        Q.push(make_pair(-d,u));
    }
    vis[1]=1;
    while(!Q.empty()){
        int now=Q.top().second;
        int D=Q.top().first;
        Q.pop();
        if(vis[now]) continue;
        vis[now]=1;
        res=res+(-D);
        for(int i=0;i<E[now].size();i++){
            int u=E[now][i].first;
            int d=E[now][i].second;
            Q.push(make_pair(-d,u));
        }
    }
    return res;
}
```

# 数学

### 费马小定理

```c++
gcd(a,p)=1,那么a^(p-1)==1(mod p)
mypow(a,k*(mod-2)) = mypow(a,k*(mod-2)%(mod-1));
```

### Cantor展开

```c++
int fac[]={1,1,2,6,24,120,720,5040,40320,362880};
int cantor(string s){
    int temp,num;
    num=0;
    for(int i=0;i<n-1;i++){//n为位数
        temp=0;
        for(int j=i+1;j<n;j++){
            if(s[j]<s[i]) temp++;
        }
        num+=fac[n-i-1]*temp;
    }
    return (num+1);
}

void getstr(int val){
    int tmp[10],flag[10];
    memset(flag,0,sizeof flag);
    for(int i=0;i<9;i++) tmp[i]=val/c[8-i],val=val%c[8-i];
    for(int i=0;i<9;i++){
        int num=0;
        for(int j=0;j<9;j++){
            if(flag[j]==0) num++;
            if(num==tmp[i]+1){
                t[i]=j+'0'+1; if(t[i]=='9') t[i]='x';
                flag[j]=1;break;
            }
        }
    }
}
```



### 快速幂

```c++
ll Pow(ll a, int b, int p) {
    a%=p; ll ans=1;
    for(; b; b>>=1, a=a*a%p)
        if(b&1) ans=ans*a%p;
    return ans;
}
```

### 筛法求素数

```c++
int p[MAX], pr[MAX];
void init() {
    p[1]=1;
    int tot = 0;
    for (int i = 2; i <= N; ++i) { // 其中N代表最大值
        if (!p[i]) p[i]=i,pr[++tot]=i;
        for (int j=1;j<=tot&&pr[j]*i<=N;j++) {
            p[i*pr[j]]=pr[j];
            if (p[i]==pr[j]) break;
        }
    }
}
```



# 图论

### Trajan O(E + V)

使用该算法需要注意的地方

* 判断出现连通分量的条件   `low[u] == number[u]`
* 该算法的入口     `if (!number[u]) trajan(u);`

#### 带环有向图缩点形成DAG

```c++
int number[MAX], head[MAX], cnt, low[MAX], s[MAX], top, scc, belong[MAX];
void dfs(int u) {
	number[u] = low[u] = ++cnt;
	int v;
	s[++top] = u;
	for (int i = head[u]; i; i = e[i].nex) {
		v = e[i].to;
		if (!number[v]) {
			dfs(v);
			low[u] = min(low[u], low[v]);
		} else if (!belong[v])	{
			low[u] = min(low[u], number[v]);
		}
	}

	int x;
	if (low[u] == number[u]) {
		++scc;
		while (true) {
			x = s[top--];
			belong[x] = scc;
			size[scc]++;
			if (x == u)	break;
		}
	}
}
void buildGraph() {
	cnt = 0;
	int v;
	for (int i = 1; i <= n; ++i) {
		for (int j = head[i]; j; j = e[j].nex) {
			v = e[j].to;
			if (belong[v] != belong[i])	add2(belong[i], belong[v]);
		}
	}
}
void trajan() {
	for (int i = 1; i <= n; ++i) {
    	if (!number[i])	dfs(i);
    }
}
```

#### 求割点

当一个点是割点，需要满足的两个条件

**1)** u is root of DFS tree and it has at least two children. 

**2)** u is not root of DFS tree and it has a child v such that no vertex in subtree rooted with v has a back edge to one of the ancestors (in DFS tree) of u.

```c++
void dfs(int u, int fa) {
	low[u] = number[u] = ++cnt;
	int v, child = 0;
	for (int i = head[u]; i; i = e[i].nex) {
		v = e[i].idx;
		if (!number[v]) {
			dfs(v, u);
			low[u] = min(low[u], low[v]);
			child++;
			if (low[v] >= number[u])	scc[u]++;
		} else if (number[v] < number[u] && v != fa) {
			low[u] = min(low[u], number[v]);
		}
	}

	if (child == 1 && fa == -1)	scc[u] = 0;
}
```

在该程序退出之后，如果scc[idx] != 0，那么该点就是割点

### Hungarian O(E$\cdot$V)

* 建图的时候只需要建立从左往右的点即可
* 在for循环中也只需要遍历左边的点即可
* 左右两边的点，对应的标记不可以相等

```c++
int match[MAX], vis[MAX];
bool dfs(int now) {
	vis[now] = 1;
	int v;
	for (int i = head[now]; i; i = e[i].nex) {
		v = e[i].to;
		if (match[v] == -1 || !vis[match[v]] && dfs(match[v])) {
			match[now] = v;
			match[v] = now;
			return true;
		}
	}
	return false;
}
int hungarian() {
	int ans = 0;
	memset(match, -1, sizeof(match));
	for (int i = 1; i <= n; ++i) {
		if (match[i] == -1) {
			memset(vis, 0, sizeof(vis)); // 可以使用技巧优化掉这个n
			if (dfs(i))	++ans;
		}
	}
	return ans;
}
```

### 欧拉回路 & 欧拉路径  O(V$\cdot $ logV) 

欧拉路径 & 欧拉回路

算法的主体是一个简单的dfs，如果使用邻接矩阵来存储图，将会达到$O(n^2)$的复杂度，而使用multiset来存储图，可以达到$O(nlgn)$的复杂度

欧拉路径的存在条件：只有两个结点的度数为奇数

欧拉回路的存在条件：整个图联通，所有结点的度数为偶数

如果是第一种情况，那么在调用dfs时应该从两个奇数度结点之一调用；后者的话则任意

一般来说，题目里会要求打印字典序最小的路径，所以一般都是选择最小度开始打印

```c++
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <set>
#include <stack>
using namespace std;
const int MAX = 3000;
multiset<int>G[300];
int n, degree[MAX];
stack<char>ans;
void dfs(int u) {
    char v;
    char c =u;
    for (auto x = G[u].begin(); x != G[u].end(); x = G[u].begin()) {
        v = *x;
        G[u].erase(x);
        G[v].erase(G[v].find(u));
        dfs(v);
    }
    ans.push(u);
}
int main() {
    scanf("%d", &n);
    char s[3];
    char u, v;
    for (int i = 1; i <= n; ++i) {
        scanf("%s", s);
        u = s[0]; v = s[1];
        degree[u] += 1;
        degree[v] += 1;
        G[u].insert(v);
        G[v].insert(u);
    }
    
    int cnt = 0, idx = 0;
    for (int i = 1; i <= 300; ++i) if (degree[i]&1) {
        ++cnt;
        if (!idx)   idx = i;
    }
    
    if (cnt && cnt != 2)    {
        printf("No Solution\n");
        return 0;
    }
    
    if (!cnt) for (int i = 'A'; i <= 'z'; ++i) if (degree[i])   {idx = i; break;}
    
    dfs(idx);
    if (ans.size() != n + 1) printf("No Solution\n");
    else {
        while (!ans.empty())  {
            printf("%c", ans.top()); ans.pop();
        }
    }
    
}

```

### 拓扑排序  O(E + V)

结果中如果某些结点的度数不为0，那么该点就一定位于某个环中

```c++
void topoSort() {
    queue<int>q;
    int u, v;
    for (int i = 1; i <= n; ++i) if (!degree[i]) {
        q.push(i);
    }

    while (!q.empty()) {
        u = q.front(); q.pop();
        for (int i = head[u]; i; i = e[i].nex) {
            v = e[i].to;
            degree[v]--;
            if (!degree[v]) q.push(v);
        }
    }
    
}
void input() {
    cnt = 0;
    memset(head, 0, sizeof(head));
    int u, v;
    memset(degree, 0, sizeof(degree));
    
    for (int i = 1; i <= m; ++i) {
        scanf("%d%d", &u, &v);
        ++u; ++v;
        add(u, v);
        degree[v]++;
    }

}
```



# 计算几何

### Graham's Scan 求凸包

1. 找到最下边的点，如果有多个点在同一y值，那么选取最左边的点

2. 以找到的点为参考点，将所有的点按照极角进行排序，方法是使用叉积

   我第一次写板子的时候没有处理好点的起点下标，果然还是从1开始比较人道

3. 使用单调栈的思路维护一个栈，该栈中最后剩下的点即为凸包

```c++
#include <iostream>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <string>
#include <algorithm>
using namespace std;
const double PI = acos(-1.0);
const double EPS = 1e-6;
const int MAX = 1005;
struct Point {
	int x, y;
	void in() {
		scanf("%d%d", &x, &y);
	}
}p[MAX];
int n, L;
int xmult(Point p0, Point p1, Point p2) {
	return (p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y);
}
double dis(Point a, Point b) {
	double dx = a.x - b.x;
	double dy = a.y - b.y;
	return sqrt(dx * dx + dy * dy);
}
bool cmpAngle(Point a, Point b) {
	int temp = xmult(p[1], a, b);
	if (temp > 0)	return true;
	else if (temp == 0 && dis(p[1], a) < dis(p[1], b))	return true;
	return false;
}
void in() {
	scanf("%d%d", &n, &L);
	p[1].in();
	int low = 1;
	for (int i = 2; i <= n; ++i) {
		p[i].in();
		if (p[i].y < p[low].y || (p[i].y == p[low].y && p[i].x < p[low].x))
			low = i;
	}
	if (low != 1)	swap(p[1], p[low]);
	sort(p + 2, p + 1 + n, cmpAngle);
}
int s[MAX], top = 0;
void graham() {
	double ans = 0;
	s[0] = 1;
	s[1] = 2;
	top = 2;
	for (int i = 3; i <= n; ++i) {
		while (top >= 2 && xmult(p[s[top - 2]], p[s[top - 1]], p[i]) <= 0)	--top;
		s[top++] = i;
	}
}
```



# 读入优化

在使用前可以使用`using namespace IO;` 之后使用`read()`  `print`

```c++
namespace IO{ 
    #define BUF_SIZE 100000 
    #define OUT_SIZE 100000 
    #define ll long long 
    //fread->read 

    bool IOerror=0; 
    inline char nc(){ 
        static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; 
        if (p1==pend){ 
            p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); 
            if (pend==p1){IOerror=1;return -1;} 
            //{printf("IO error!\n");system("pause");for (;;);exit(0);} 
        } 
        return *p1++; 
    } 
    inline bool blank(char ch){return ch==' '||ch=='\n'||ch=='\r'||ch=='\t';} 
    inline void read(int &x){ 
        bool sign=0; char ch=nc(); x=0; 
        for (;blank(ch);ch=nc()); 
        if (IOerror)return; 
        if (ch=='-')sign=1,ch=nc(); 
        for (;ch>='0'&&ch<='9';ch=nc())x=x*10+ch-'0'; 
        if (sign)x=-x; 
    } 
    inline void read(ll &x){ 
        bool sign=0; char ch=nc(); x=0; 
        for (;blank(ch);ch=nc()); 
        if (IOerror)return; 
        if (ch=='-')sign=1,ch=nc(); 
        for (;ch>='0'&&ch<='9';ch=nc())x=x*10+ch-'0'; 
        if (sign)x=-x; 
    } 
    inline void read(double &x){ 
        bool sign=0; char ch=nc(); x=0; 
        for (;blank(ch);ch=nc()); 
        if (IOerror)return; 
        if (ch=='-')sign=1,ch=nc(); 
        for (;ch>='0'&&ch<='9';ch=nc())x=x*10+ch-'0'; 
        if (ch=='.'){ 
            double tmp=1; ch=nc(); 
            for (;ch>='0'&&ch<='9';ch=nc())tmp/=10.0,x+=tmp*(ch-'0'); 
        } 
        if (sign)x=-x; 
    } 
    inline void read(char *s){ 
        char ch=nc(); 
        for (;blank(ch);ch=nc()); 
        if (IOerror)return; 
        for (;!blank(ch)&&!IOerror;ch=nc())*s++=ch; 
        *s=0; 
    } 
    inline void read(char &c){ 
        for (c=nc();blank(c);c=nc()); 
        if (IOerror){c=-1;return;} 
    } 
    //fwrite->write 
    struct Ostream_fwrite{ 
        char *buf,*p1,*pend; 
        Ostream_fwrite(){buf=new char[BUF_SIZE];p1=buf;pend=buf+BUF_SIZE;} 
        void out(char ch){ 
            if (p1==pend){ 
                fwrite(buf,1,BUF_SIZE,stdout);p1=buf; 
            } 
            *p1++=ch; 
        } 
        void print(int x){ 
            static char s[15],*s1;s1=s; 
            if (!x)*s1++='0';if (x<0)out('-'),x=-x; 
            while(x)*s1++=x%10+'0',x/=10; 
            while(s1--!=s)out(*s1); 
        } 
        void println(int x){ 
            static char s[15],*s1;s1=s; 
            if (!x)*s1++='0';if (x<0)out('-'),x=-x; 
            while(x)*s1++=x%10+'0',x/=10; 
            while(s1--!=s)out(*s1); out('\n'); 
        } 
        void print(ll x){ 
            static char s[25],*s1;s1=s; 
            if (!x)*s1++='0';if (x<0)out('-'),x=-x; 
            while(x)*s1++=x%10+'0',x/=10; 
            while(s1--!=s)out(*s1); 
        } 
        void println(ll x){ 
            static char s[25],*s1;s1=s; 
            if (!x)*s1++='0';if (x<0)out('-'),x=-x; 
            while(x)*s1++=x%10+'0',x/=10; 
            while(s1--!=s)out(*s1); out('\n'); 
        } 
        void print(double x,int y){ 
            static ll mul[]={1,10,100,1000,10000,100000,1000000,10000000,100000000, 
                1000000000,10000000000LL,100000000000LL,1000000000000LL,10000000000000LL, 
                100000000000000LL,1000000000000000LL,10000000000000000LL,100000000000000000LL}; 
            if (x<-1e-12)out('-'),x=-x;x*=mul[y]; 
            ll x1=(ll)floor(x); if (x-floor(x)>=0.5)++x1; 
            ll x2=x1/mul[y],x3=x1-x2*mul[y]; print(x2); 
            if (y>0){out('.'); for (size_t i=1;i<y&&x3*mul[i]<mul[y];out('0'),++i); print(x3);} 
        } 
        void println(double x,int y){print(x,y);out('\n');} 
        void print(char *s){while (*s)out(*s++);} 
        void println(char *s){while (*s)out(*s++);out('\n');} 
        void flush(){if (p1!=buf){fwrite(buf,1,p1-buf,stdout);p1=buf;}} 
        ~Ostream_fwrite(){flush();} 
    }Ostream; 
    inline void print(int x){Ostream.print(x);} 
    inline void println(int x){Ostream.println(x);} 
    inline void print(char x){Ostream.out(x);} 
    inline void println(char x){Ostream.out(x);Ostream.out('\n');} 
    inline void print(ll x){Ostream.print(x);} 
    inline void println(ll x){Ostream.println(x);} 
    inline void print(double x,int y){Ostream.print(x,y);} 
    inline void println(double x,int y){Ostream.println(x,y);} 
    inline void print(char *s){Ostream.print(s);} 
    inline void println(char *s){Ostream.println(s);} 
    inline void println(){Ostream.out('\n');} 
    inline void flush(){Ostream.flush();}
    #undef ll 
    #undef OUT_SIZE 
    #undef BUF_SIZE 
};
```



# 注意事项

1. 读题！读题！读题！有没有地方是理解错了的！  (二进制  ->  十进制)
2. Debug  -> 看看有没有什么变量拼错了，搞成了另外一个变量 !!!
3. 链式前向星，注意开双倍大小!! 在二分图建模时可能会是平方大小!!!
4. 输出的格式对不对!!! "YES"  "NO"
5. zkw线段树，传入的区间是左闭右开
6. 线段树出现RE的调试方法
   * 将线段树数组开成 `MAX<<4`
   * 将线段树的使用容量每次都开到最大
   * 保证线段树的左区间最小为1
