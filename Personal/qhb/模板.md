[TOC]

# JAVA大数

### 使用大整数的compareTo()函数

```java
import java.util.*;
import java.math.*;
import java.lang.*;
public class Main{
    public static void main(String[] args) {
        Scanner cin = new Scanner(System.in);
        BigInteger []ans = new BigInteger[2005];
        ans[1] = BigInteger.ONE;
        ans[2] = BigInteger.ONE.add(ans[1]);
        for(int i = 3; i < 2000; ++i){
            ans[i] = ans[i - 1].add(ans[i - 2]);
            if(ans[i].toString().length() > 100)   {
                break;
            }
        }
        BigInteger a, b;
        while(true) {
            a = cin.nextBigInteger();
            b = cin.nextBigInteger();
            if(a.compareTo(BigInteger.ZERO) == 0 && b.compareTo(BigInteger.ZERO) == 0) break;
            int c = 0;
            for(int i = 1; i <= 480; ++i)
                if(a.compareTo(ans[i]) <= 0 && ans[i].compareTo(b) <= 0) ++c;
            System.out.println(c);
        }
    }
}
```

### 使用大浮点数的内建方法

```java
import java.util.*;
import java.math.*;
import java.lang.*;
public class Main{
    public static void main(String[] args) {
        BigDecimal ans;
        int n;
        Scanner cin = new Scanner(System.in);
        while(cin.hasNext()) {
            ans = cin.nextBigDecimal();
            n = cin.nextInt();
            String a = ans.pow(n).stripTrailingZeros().toPlainString();//去除末尾多余的零
            while(a.charAt(0) == '0')  a = a.substring(1);
            System.out.println(a);
        }
    }
}
```

### 使用自带的Miller Rabin方法

```java
public class Main {
    public static void main(String[] args) {
        InputReader reader = new InputReader();
        PrintWriter out = new PrintWriter(System.out);
        int t = reader.nextInt();
        while (t-- > 0) {
            long n = reader.nextLong();
            long half = n / 2;
            int get = (int) (half % 10);
            // if (isPrime(n - 5)) {
            // if (Miller_Rabin(n - 5)) {
            if (BigInteger.valueOf(n - 5).isProbablePrime(5)) {
                out.println(5 + " " + (n - 5));
                continue;
            }
            while (half > 0) {
                // System.out.println(half);
                if (get == 1 || get == 7 || get == 9 || get == 3) {
                    // if (isPrime(get)) {
                    // if (Miller_Rabin(half)) {
                    if (BigInteger.valueOf(half).isProbablePrime(5)) {
                        long half2 = n - half;
                        long get2 = half2 % 10;
                        if (get2 == 1 || get2 == 7 || get2 == 9 || get2 == 3) {
                            // if (isPrime(half2)) {
                            // if (Miller_Rabin(half2)) {
                            if (BigInteger.valueOf(half2).isProbablePrime(5)) {
                                out.println(half + " " + half2);
                                break;
                            }
                        }
                    }
                }
                half--;
                get = (int) (half % 10);
            }
        }
        out.close();
    }
}
```



### 大数乘除

```java
import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.math.BigInteger;
import java.util.Scanner;

public class Main {
	public static void main(String[] args) throws FileNotFoundException {
		Scanner cin = new Scanner(new File("input.txt"));
		PrintWriter print = new PrintWriter(new File("output.txt"));
		int n;
		BigInteger []t = new BigInteger[307];
		BigInteger []num = new BigInteger[307];
		num[3] = BigInteger.valueOf(2);
		num[6] = BigInteger.valueOf(9);
		t[12] = BigInteger.valueOf(17);
		num[9] = BigInteger.valueOf(38);
		for(int i = 12;i<=300;i+=3){
			if((i%2)==0){
				num[i] = num[i-3].multiply(BigInteger.valueOf(4)).subtract(t[i]);
				t[i+6] = t[i].multiply(BigInteger.valueOf(4)).add(BigInteger.valueOf(21));
			}else {
				num[i] = num[i-3].multiply(BigInteger.valueOf(4)).add(BigInteger.valueOf(2));
			}
		}
		while(cin.hasNext()){
			n = cin.nextInt();
			print.println(num[n]);
		}
		cin.close();
		print.close();
	}
}
```

### 使用String初始化BigInteger

```java
BigInteger now = new BigInteger("100000");
```



# KMP

### 查询有多少个匹配串

```c++
int nex[MAX];
void get_next(int *b, int m)    //b为被要求匹配的串
{
	int i = 0, j = -1;
	nex[i] = j;
	while(i < m) {
		if(j == -1 || b[i] == b[j]) {
			++i; ++j;
			nex[i] = j;
		} else j = nex[j];
	}
}
int kmp(int *buf,int *str, int n, int m)    //在buf中寻找有多少个str串，n为前者长度
{											//m为后者长度，下标均从0开始计数
	int i = 0, j = 0, ans = 0;
	while(i < n) {
		if(j == -1 || buf[i] == str[j]) {
			++i; ++j;
			if(j == m) {
				++ans; j = nex[j];
			}
		} else j = nex[j];
	}
	return ans;
}
```



# 数据结构

## 数组型线段树

注意的几个地方

* 数组的容量应该开成最大容量的四倍，即`MAX<<2`
* 在需要对线段树中的所有元素进行遍历时，可以在`query`函数中对区间进行操作，将会减小常数
* 懒惰标记的关键是`push()` & `up()`，在`update()` & `query()`里面都需要如此设置

### 区间染色

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <vector>
using namespace std;
const int N = 8e4 + 5;
const int MAX = 8e4 + 1;
int color[N];
struct Node {
	int color, time;
}t[N<<1];
void build() {
	for(int i = 1; i < (N<<1); ++i)
		t[i].color = -1, t[i].time = 0;
}
void update(int l, int r, int color, int time) {
	for(l += MAX, r += MAX; l < r; l >>= 1, r >>= 1) {
		if(l&1)	t[l].color = color, t[l++].time = time;
		if(r&1)	t[--r].color = color, t[r].time = time;
	}
}
void push() {
	for(int i = 1; i < MAX; ++i) {
		if(t[i].time > t[i<<1].time)	t[i<<1].time = t[i].time, t[i<<1].color = t[i].color;
		if(t[i].time > t[i<<1|1].time)	t[i<<1|1].time = t[i].time, t[i<<1|1].color = t[i].color;
	}
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int m, l, r, c;
	while(cin >> m) {
		build();
		for(int i = 1; i <= m; ++i) {
			cin >> l >> r >> c;
			update(l, r, c, i);
		}
		push();
		memset(color, 0, sizeof(color));
		int now = -1;
		for(int i = 0 + MAX; i <= MAX + MAX; ++i) {
			if(now == -1) {
				if(t[i].color == -1)	continue;
				now = t[i].color;
			} else {
				if(t[i].color == now)	continue;
				else {
					color[now]++;
					now = t[i].color;
				}
			}
		}

		for(int i = 0; i < MAX; ++i)
			if(color[i])	cout << i << " " << color[i] << '\n';
		cout << '\n';
	}
}
```

### 懒惰标记

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <cmath>
#include <vector>
using namespace std;
const int MAX = 2e5 + 5;
struct Node {
	bool type;//if all values in this segment are '1'
	long long val;
}t[MAX];
int n, m;
void build() {
	for(int i = n - 1; i > 0; --i) {
		if(t[i<<1].type && t[i<<1|1].type)	t[i].type = 1;
		else	t[i].type = 0;
		t[i].val = t[i<<1].val + t[i<<1|1].val;
	}
}
void up(int x) {
	while(x > 1) {
		t[x>>1].val = t[x].val + t[x^1].val;
		x >>= 1;
	}
}
long long deal(int x) {
	if(t[x].type == 1)	return t[x].val;
	if(x >= n) {
//		cout << x << " " << t[x].val << " -> " << (int)sqrt(t[x].val) << endl;
		t[x].val = sqrt(t[x].val);
//		cout << "now : " << t[x].val << endl;
		if(t[x].val <= 1)	t[x].type = 1;
		up(x);
		return t[x].val;
	}
	if(t[x<<1].type != 1)	deal(x<<1);
	if(t[x<<1|1].type != 1)	deal(x<<1|1);

	t[x].val = t[x<<1].val + t[x<<1|1].val;
	if(t[x<<1].type && t[x<<1|1].type)	t[x].type = 1;
	up(x);
	return t[x].val;
}
void update(int l, int r) {
	for(l += n, r += n; l < r; l >>= 1, r >>= 1) {
		if(l&1) deal(l++);
		if(r&1)	deal(--r);
	}
}
long long query(int l, int r) {
	long long ans = 0;
	for(l += n, r += n; l < r; l >>= 1, r >>= 1) {
		if(l&1)	{
			ans += t[l++].val;
		}
		if(r&1)	{
			ans += t[--r].val;
		}
	}
	return ans;
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int cnt = 1;
	// freopen("input", "r", stdin);
	// freopen("output.a", "w", stdout);
	while(cin >> n) {
		cout << "Case #" << cnt++ << ":\n";
		for(int i = 0; i < n; ++i) {
			cin >> t[i + n].val;
			if(t[i + n].val <= 1)	t[i + n].type = 1;
			else	t[i + n].type = 0;
		}
		build();
		cin >> m;
		int type, l, r;
		while(m--) {
			cin >> type >> l >> r;
			if(l > r)	swap(l, r);
			if(type == 0)	update(l - 1, r);
			else	cout << query(l - 1, r) << '\n';
		}
		cout << '\n';
	}
}
```



### 矩形周长并

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;
const int MAX = 2e4 + 5;

struct Edge1 {
    int x, y1, y2, type;
    Edge1(int a = 0, int b = 0, int c = 0, int d = 0): x(a), y1(b), y2(c), type(d) {}
    bool operator < (const Edge1 b) const {
        if (x != b.x)   return x < b.x;
        return type > b.type;
    }
};
struct Edge2 {
    int y, x1, x2, type;
    Edge2(int a = 0, int b = 0, int c = 0, int d = 0): y(a), x1(b), x2(c), type(d) {}
    bool operator < (const Edge2 b) const {
        if (y != b.y)   return y < b.y;
        return type > b.type;
    }
};
struct Node {
    int l, r, len, times;
}t[MAX<<2];
void build(int i, int l, int r) {
    t[i].l = l; t[i].r = r; t[i].len = t[i].times = 0;
    if (l == r) return ;
    int mid = l + r >> 1;
    build(i<<1, l, mid); build(i<<1|1, mid + 1, r);
}
void up(int i) {
    if (t[i].times) t[i].len = t[i].r - t[i].l + 1;
    else if (t[i].l == t[i].r)  t[i].len = 0;
    else t[i].len = t[i<<1].len + t[i<<1|1].len;
}
void update(int i, int l, int r, int val) {
    // cout << t[i].l << ' ' << t[i].r << ' ' << l << ' ' << r << endl;
    if (t[i].l == l && t[i].r == r) {
        t[i].times += val;
        up(i);
        return ;
    }
    int mid = t[i].l + t[i].r >> 1;
    if (r <= mid)   update(i<<1, l, r, val);
    else if (l > mid)   update(i<<1|1, l, r, val);
    else {
        update(i<<1, l, mid, val);
        update(i<<1|1, mid + 1, r, val);
    }
    up(i);
}
int n, minX, minY, maxX, maxY, ans;
vector<Edge1>e1;
vector<Edge2>e2;
void input() {
    e1.clear(); e2.clear();
    int x1, x2, y1, y2;
    minX = 1<<30; minY = 1<<30;
    maxX = -(1<<30); maxY = -(1<<30);
    for (int i = 1; i <= n; ++i) {
        scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
        // x1 += 10001; x2 += 10001; y1 += 10001; y2 += 10001;
        e1.push_back(Edge1(x1, y1, y2, 1));
        e1.push_back(Edge1(x2, y1, y2, -1));
        e2.push_back(Edge2(y1, x1, x2, 1));
        e2.push_back(Edge2(y2, x1, x2, -1));
        minX = min(minX, x1);
        minY = min(minY, y1);
        maxX = max(maxX, x2);
        maxY = max(maxY, y2);
    }
    sort(e1.begin(), e1.end());
    sort(e2.begin(), e2.end());
    n *= 2;
}

void deal() {
    ans = 0;
    int last = 0, now = 0;
    build(1, 1, maxY - minY + 1);
    for (int i = 0; i < n; ++i) {
        update(1, e1[i].y1 - minY + 1, e1[i].y2 - minY, e1[i].type);
        last = now;
        now = t[1].len;
        ans += abs(now - last);
        // cout << now << endl;
    }

    last = 0; now = 0;
    build(1, 1, maxX - minX + 1);
    for (int i = 0; i < n; ++i) {
        update(1, e2[i].x1 - minX + 1, e2[i].x2 - minX, e2[i].type);
        last = now;
        now = t[1].len;
        ans += abs(now - last);

    }
}
int main() {
    // freopen("input.txt", "r", stdin);
    while (scanf("%d", &n) != EOF) {
        if (n == 0) {
            printf("0\n");
            continue;
        }
        input();
        deal();
        printf("%d\n", ans);
    }
}
```



### 矩形面积并

大体上的思路同周长并；线段树中的每一个结点保存一个线段，而不是点；因此在update中传入的上边界减一；离散化之后得到对应的边长比较tricky，在使用的时候需要将上标加一

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <algorithm>
#include <vector>
#include <map>
using namespace std;
const int MAX = 1e5 + 5;
struct Node {
    int l, r, times;
    double len;
}t[MAX<<3];
void build(int i, int l, int r) {
    t[i].l = l; t[i].r = r; t[i].len = t[i].times = 0;
    if (l == r) return ;
    int mid = (l + r) >> 1;
    build(i<<1, l, mid); build(i<<1|1, mid + 1, r);
}
struct Edge {
    double x, y1, y2;
    int val;
    Edge(double _1 = 0, double _2 = 0, double _3 = 0, int _4 = 0): x(_1), y1(_2), y2(_3), val(_4) {}
    bool operator < (const Edge b) const {
        if (x != b.x)   return x < b.x;
        return val > b.val;
    }
};
vector<Edge>e;
map<double, int>mp;
vector<double>temp;
int Max;
double a[MAX];
void preTreatment() {
    sort(temp.begin(), temp.end());
    mp[temp[0]] = 1;
    a[1] = temp[0];
    int len = temp.size(), cnt = 1;
    for (int i = 1; i < len; ++i) {
        if (temp[i] == temp[i - 1]) continue;
        else    mp[temp[i]] = ++cnt, a[cnt] = temp[i];
    }
    Max = cnt;
}
void up(int i) {
    if (t[i].times) t[i].len = a[t[i].r + 1] - a[t[i].l];
    else if (t[i].l == t[i].r)  t[i].len = 0;
    else    t[i].len = t[i<<1].len + t[i<<1|1].len;
}
void update(int i, int l, int r, int val) {
    if (t[i].l == l && t[i].r == r) {
        t[i].times += val;
        up(i);
        return ;
    }
    int mid = t[i].l + t[i].r >> 1;
    if (r <= mid)   update(i<<1, l, r, val);
    else if (l > mid)   update(i<<1|1, l, r, val);
    else {
        update(i<<1, l, mid, val);
        update(i<<1|1, mid + 1, r, val);
    }
    up(i);
}

int main() {
    // freopen("input.txt", "r", stdin);
    int n, cnt = 1;
    while (scanf("%d", &n) && n) {
        double x1, x2, y1, y2;
        e.clear(); temp.clear();
        for (int i = 1; i <= n; ++i) {
            scanf("%lf%lf%lf%lf", &x1, &y1, &x2, &y2);
            temp.push_back(y1); temp.push_back(y2);
            e.push_back(Edge(x1, y1, y2, 1));
            e.push_back(Edge(x2, y1, y2, -1));
        }
        sort(e.begin(), e.end());
        preTreatment();
        build(1, 1, Max + 1);
        double ans = 0, now = 0, x;
        for (int i = 0; i < 2*n; ++i) {
            ans += now * (e[i].x - x);
            // cout << mp[e[i].y1] << ' ' << mp[e[i].y2] << endl;
            update(1, mp[e[i].y1], mp[e[i].y2] - 1, e[i].val);
            now = t[1].len;
            x = e[i].x;
            // cout << now << endl;

        }
        printf("Test case #%d\nTotal explored area: %.2lf\n\n", cnt++, ans);
    }
}
```



## zkw线段树

### 在线更新

```c++
#include <iostream>
#include <cstring>
#include <string>
#include <cstdio>
using namespace std;
string s;
const int MAX = 1e6 + 5;
struct Node {
	int l, r, ans;
	Node(int a = 0, int b = 0, int c = 0): l(a), r(b), ans(c) {}
}t[MAX * 2];
int n;
Node combine(Node& a, Node& b) {
	int add = min(a.l, b.r);
	return Node(a.l - add + b.l, b.r - add + a.r, a.ans + b.ans + add); 
}
void build(int n) {
	for (int i = n - 1; i > 0; --i)
		t[i] = combine(t[i<<1], t[i<<1|1]);
}
Node query(int l, int r) {
	Node L, R;
	for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
		if (l&1)	L = combine(L, t[l++]);
		if (r&1)	R = combine(t[--r], R);
	}
	return combine(L, R);
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> s;
	n = s.size();
	for (int i = 0; i < n; ++i) {
		if (s[i] == '(')
			t[i + n] = Node(1, 0, 0);
		else	
			t[i + n] = Node(0, 1, 0);
	}
	build(n);

	int k, l, r;
	Node ans;
	cin >> k;
	while (k--) {
		cin >> l >> r;
		ans = query(l - 1, r);
		cout << ans.ans * 2 << '\n';
	}
}
```

### 求逆序对

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
const int MAX = 1e6 + 5;
int t[MAX<<1], n;
void update(int x) {
	for (t[x += n]++; x > 1; x >>= 1) {
		t[x>>1] = t[x] + t[x^1];
	}
}
int query(int l, int r) {
	int ans = 0;
	for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
		if (l&1)	ans += t[l++];
		if (r&1)	ans += t[--r];
	}
	return ans;
}

int a[MAX];
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n;
	for (int i = 1; i <= n; ++i)	cin >> a[i];
	long long ans = 0;
	for (int i = 1; i <= n; ++i) {
		if (a[i] != n)	ans += query(a[i] + 1, n + 1);
		// cout << ans << endl;
		update(a[i]);
	}

	// cout << ans << endl;

	if (n&1) {
		if (ans&1)	cout << "Petr";
		else	cout << "Um_nik";
	} else {
		if (ans&1)	cout << "Um_nik";
		else	cout << "Petr";
	}
	return 0;
}
```

## 树状数组

### 单点更新 区间查询

```c++
inline int lowbit(int x) {return x & -x;}
void add(int i, ll x) {
    for (; i <= n; i += lowbit(i)) C[i] += x;
}
ll query(int i) {
    ll ans = 0;
    for (; i; i -= lowbit(i)) ans += C[i];
    return ans;
}
```

### 区间更新 单点查询

具体函数没有差别，只是在使用的时候，操作对象是差分数组



## 主席树

- 根结点的大小开成数组中元素的个数，每个代表一棵新的线段树

- build函数首先需要建立一棵空树，表示第一个历史版本

- build函数的声明 `void build(int &i, int l, int r)`

- update函数 `int update(int i, int l, int r, int idx)`

- lower_bound函数，返回第一个小于或等于给定元素的位置，如果没有找到，那么返回最后一个越界索引

  如对于a[1..n] 调用，发生越界，那么返回的结果在 n + 1

- unique函数，对有序数组去重，返回的可以认为是最后一个越界索引

  如对于a[1...n]调用，正确得到其去重后结果的大小应该是

  `int len = unique(a + 1, a + 1 + n) - a - 1;`

- u 和 v 不要写反。。如果写反了，那么答案里面可能会生成负数

- 对于每一次新的时间轴，一定要继承上一次的状态

  因为有的题目时间轴是跳着的，如果仅对时间轴进行操作，每次从上一个状态转移而来，将会丢失状态

- 此处函数之间传递的`l & r`与线段树不一样，当时传递的是关心的区间，此时传递的是当前结点对应的区间

- 对多组数据，记得每次要把cnt清零，否则必定出现数组越界

  数组越界的另外一个可能是数组开小了

  数组越界的返回结果可能是 TLE

  因为每次创建新树至多新加入了 $2*log_2(n)$个结点，所以最保险的做法就是用最大容量乘以左边的数字

### 差分

#### 静态求区间第k大

```c++
const int MAX = 2e5 + 5;
int sum[MAX<<5], L[MAX<<5], R[MAX<<5], root[MAX], cnt, a[MAX], b[MAX];
//build an empty tree
void build(int &i, int l, int r) {
    i = ++cnt; sum[i] = 0;
    if (l == r) return ;
    int mid = l +r >> 1;
    build(L[i], l, mid); build(R[i], mid + 1, r);
}

//create the new node while traversing the tree
int modify(int i, int l, int r, int idx) {
    int ii = ++cnt;
    L[ii] = L[i]; R[ii] = R[i]; sum[ii] = sum[i] + 1;
    if (l == r) return ii;
    int mid = l + r >> 1;
    if (idx <= mid) L[ii] = modify(L[ii], l, mid, idx);
    else R[ii] = modify(R[ii], mid + 1, r, idx);
    return ii;
}

//find the exact location of the k-th minimum value in [l, r]
int query(int u, int v, int l, int r, int k) {
    int x = sum[L[v]] - sum[L[u]];
    if (l == r) return l;
    int mid = l + r >> 1;
    if (k <= x) return query(L[u], L[v], l, mid, k);
    else    return query(R[u], R[v], mid + 1, r, k - x);
}

int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i)    scanf("%d", &b[i]), a[i] = b[i];
    sort(b + 1, b + 1 + n);
    int len = unique(b + 1, b + 1 + n) - b - 1;
    build(root[0], 1, len);
    
    int val;
    for (int i = 1; i <= n; ++i) {
        val = lower_bound(b + 1, b + 1 + len, a[i]) - b;
        root[i] = modify(root[i - 1], 1, len, val);
    }

    int l, r, k;
    for (int i = 1; i <= m; ++i) {
        scanf("%d%d%d", &l, &r, &k);
        printf("%d\n", b[query(root[l - 1], root[r], 1, len, k)]);
    }
}
```

### 维护多棵线段树

#### 统计[l, r]中前k小的数据之和

```c++
ll query(int i, int l, int r, int k) {
    if (num[i] <= k)    return sum[i];
    int mid = l + r >> 1;
    if (l == r) return 1LL * k * b[l];
    if (k <= num[L[i]]) return query(L[i], l, mid, k);
    else return sum[L[i]] + query(R[i], mid + 1, r, k - num[L[i]]);
}
int main() {
    int n, m; scanf("%d%d", &m, &n);
    int s, p, val;
    for (int i = 1; i <= m; ++i) {
        scanf("%d%d%d", &s, &p, &val);
        c[i<<1] = Node(s, val, 1);
        c[(i<<1) - 1] = Node(p + 1, val, -1);
        a[i] = b[i] = val;
    }
    sort(c + 1, c + 1 + m*2); sort(b + 1, b + 1 + m);
    int len = unique(b + 1, b + 1 + m) - b - 1;
    build(root[0], 1, len);
    
    int cnt_ = 1;
    for (int i = 1; i <= n; ++i) {
        bool flag = true;
        while (cnt_ <= m*2 && c[cnt_].t == i) {
            s = lower_bound(b + 1, b + 1 + len, c[cnt_].val) - b;
            int ttt = c[cnt_].val;
            root[i] = update(root[i - flag], 1, len, s, c[cnt_].val, c[cnt_].type);
            flag = false;
            ++cnt_;
        }
        if (flag)   root[i] = root[i - 1];
    }
    
    ll a, b, c ,pre = 1;
    int t, k;
    while (n--) {
        scanf("%d%lld%lld%lld", &t, &a, &b, &c);
        k = 1 + (a % c * pre % c+ b) % c;
        pre = query(root[t], 1, len, k);
        printf("%lld\n", pre);
    }
}
```

#### 统计[l, r]中**数字第一次出现的索引构成的数组**的中位数 

```c++
for (int i = n; i >= 1; --i) {
    if (!last[a[i]]) root[i] = update(root[i + 1], 1, n, i, 1);
    else {
        root[i] = update(root[i + 1], 1, n, last[a[i]], -1);
        root[i] = update(root[i], 1, n, i, 1);
    }
    last[a[i]] = i;
}
```



## Huffman Tree

动态开点哈夫曼树

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
#include <map>
#include <string>
using namespace std;
const int MAX = 2e4 + 5;
const int MAXX = 2e5 + 5;
char t[MAXX], now[14], c, in[MAXX];
string message, final_, temp, ans;
int L[MAXX], R[MAXX], len, node, id;
void build(int i, int cnt) {
    if (cnt == len) {t[i] = c; return ;}
    else if (now[cnt] == '0') {
        if (!L[i]) L[i] = ++node;
        build(L[i], cnt + 1);
    } else {
        if (!R[i])  R[i] = ++node;
        build(R[i], cnt + 1);
    }
}
bool query(int i) {
    if (id >= len) return false;
    if (t[i] != 0) {ans += t[i]; return true;}
    ++id;
    if (final_[id] == '0')  return query(L[i]);
    return query(R[i]);
}
map<char, string>mp;
int main() {
    mp['0'] = "0000"; mp['1'] = "0001"; mp['2'] = "0010"; mp['3'] = "0011"; mp['4'] = "0100"; mp['5'] = "0101"; mp['6'] = "0110"; mp['7'] = "0111";
    mp['8'] = "1000"; mp['9'] = "1001"; mp['A'] = "1010"; mp['B'] = "1011"; mp['C'] = "1100"; mp['D'] = "1101"; mp['E'] = "1110"; mp['F'] = "1111";
    mp['a'] = "1010"; mp['b'] = "1011"; mp['c'] = "1100"; mp['d'] = "1101"; mp['e'] = "1110"; mp['f'] = "1111";
    int T; scanf("%d", &T);
    while (T--) {
        memset(t, 0, sizeof(t));
        memset(L, 0, sizeof(L));
        memset(R, 0, sizeof(R));
        int m, n; scanf("%d%d", &m, &n);
        node = 1;
        for (int i = 1, tt; i <= n; ++i) {
            scanf("%d%s", &tt, now);
            c = tt;
            len = strlen(now);
            build(1, 0);
        }
        message = "";
        scanf("%s", in);
        len = strlen(in);
        for (int i = 0; i < len; ++i) message += mp[in[i]];
        
        // cout << endl << message << endl;
        len *= 4;
        int idx = 0, cnt;
        final_ = "";
        // cout << len << endl; 
        while (true) {
            if (len - idx < 9)  break;
            cnt = 0;
            temp = "";
            for (int i = 0; i < 8; ++i)  {temp += message[i + idx]; if (message[i + idx] == '1') ++cnt;}
            if (cnt % 2 == 0 && message[idx + 8] == '1') final_ += temp;
            if (cnt % 2 == 1 && message[idx + 8] == '0') final_ += temp;
            // cout << endl << temp << ' ' << message[idx + 8] << ' ' << idx + 8 << endl;
            idx += 9;
        }
        
        len = final_.size();
        // cout << endl << final_ << endl;
        ans = ""; id = -1;
        while (true)    {if (query(1) == 0) break;}
        for (int i = 0; i < min(m, (int)ans.size()); ++i) printf("%c", ans[i]);
        puts("");
    }
}


```



# 数学

### 矩阵模板

注意，对矩阵的最大容量应该限制得尽量小

如果存在大量的乘法以及快速幂，那么会导致申请了很多个矩阵，也就是很多个memset()

```c++
struct Mat{
    int row, col, N[25][25];
    Mat(int row = 0 , int col = 0){
        memset(N, 0, sizeof(N));
        this -> row = row;
        this -> col = col;
    }
    Mat operator * (const Mat B) const {
        Mat A(row, B.col);
        for(int i = 0 ;i < row; i ++)
            for(int k = 0 ; k < col; k ++)
                for(int j = 0 ; j < B.col; j++){
                    A.N[i][j] = (A.N[i][j] + (ll)N[i][k] * B.N[k][j] + mod) % mod;
                }
        return A;
    }
    Mat operator ^ (int x) const {
        Mat A(row,row) , temp = *this;
        for(int i = 0 ; i < row; i ++)  A.N[i][i] = 1;
        while(x){
            if(x & 1)   A = A * temp;
            temp = temp * temp;
            x >>= 1;
        }
        return A;
    }
};
```



### 逆元 + 组合数

```c++
const int mod=1e9+7;
int extgcd(int a,int b,int &x,int &y){
    int d=a;
    if(b!=0){
        d=extgcd(b,a%b,y,x);
        y-=(a/b)*x;
    }
    else    x=1,y=0;
    return d;
}
int inv(int a){
    int x,y,d=extgcd(a,mod,x,y);
    x=(x%mod+mod)%mod;
    return x;
}

void inv_init(){//逆元预处理
    inv[1]=1;
    for(int i=2;i<=1000000;i++){
        inv[i]=inv[mod%i]*(mod-mod/i)%mod;
    }
}

int fac[200005];

int fun(int a,int b){
    int x=inv((1LL*fac[b]*fac[a-b])%mod);
    return (1LL*fac[a]*x)%mod;
}

void c_init(){//组合数预处理
    for (i=0;i<maxn;i++) c[i][0]=1;
    for (i=1;i<=3000;i++){
        for (j=1;j<=i;j++){
            c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
        }
    }
}
```



### 欧拉函数

``` c++
void getEuler(){
    memset(euler, 0, sizeof(euler));
    euler[1]=1;
    for(int i=2;i<maxn;i++){
        if(!euler[i]){
            for(int j=i;j<maxn;j+=i){
                if(!euler[j])
                    euler[j]=j;
                euler[j]=euler[j]/i*(i-1);
            }
        }
    }
}
```



### 费马小定理

```c++
gcd(a,p)=1,那么a^(p-1)==1(mod p)
mypow(a,k*(mod-2)) = mypow(a,k*(mod-2)%(mod-1));
```



### Cantor展开

```c++
int fac[]={1,1,2,6,24,120,720,5040,40320,362880};
int cantor(string s){
    int temp,num;
    num=0;
    for(int i=0;i<n-1;i++){//n为位数
        temp=0;
        for(int j=i+1;j<n;j++){
            if(s[j]<s[i]) temp++;
        }
        num+=fac[n-i-1]*temp;
    }
    return (num+1);
}

void getstr(int val){
    int tmp[10],flag[10];
    memset(flag,0,sizeof flag);
    for(int i=0;i<9;i++) tmp[i]=val/c[8-i],val=val%c[8-i];
    for(int i=0;i<9;i++){
        int num=0;
        for(int j=0;j<9;j++){
            if(flag[j]==0) num++;
            if(num==tmp[i]+1){
                t[i]=j+'0'+1; if(t[i]=='9') t[i]='x';
                flag[j]=1;break;
            }
        }
    }
}
```



### 快速幂

```c++
ll Pow(ll a, int b, int p) {
    a%=p; ll ans=1;
    for(; b; b>>=1, a=a*a%p)
        if(b&1) ans=ans*a%p;
    return ans;
}
```

### 筛法求素数

```c++
int p[MAX], pr[MAX];
void init() {
    p[1]=1;
    int tot = 0;
    for (int i = 2; i <= N; ++i) { // 其中N代表最大值
        if (!p[i]) p[i]=i,pr[++tot]=i;
        for (int j=1;j<=tot&&pr[j]*i<=N;j++) {
            p[i*pr[j]]=pr[j];
            if (p[i]==pr[j]) break;
        }
    }
}
```



# 图论

### Trajan O(E + V)

使用该算法需要注意的地方

* 判断出现连通分量的条件   `low[u] == number[u]`
* 该算法的入口     `if (!number[u]) trajan(u);`

#### 缩点形成DAG

```c++
int number[MAX], head[MAX], cnt, low[MAX], s[MAX], top, scc, belong[MAX];
void dfs(int u) {
	number[u] = low[u] = ++cnt;
	int v;
	s[++top] = u;
	for (int i = head[u]; i; i = e[i].nex) {
		v = e[i].to;
		if (!number[v]) {
			dfs(v);
			low[u] = min(low[u], low[v]);
		} else if (!belong[v])	{
			low[u] = min(low[u], number[v]);
		}
	}

	int x;
	if (low[u] == number[u]) {
		++scc;
		while (true) {
			x = s[top--];
			belong[x] = scc;
			size[scc]++;
			if (x == u)	break;
		}
	}
}
void buildGraph() {
	cnt = 0;
	int v;
	for (int i = 1; i <= n; ++i) {
		for (int j = head[i]; j; j = e[j].nex) {
			v = e[j].to;
			if (belong[v] != belong[i])	add2(belong[i], belong[v]);
		}
	}
}
void trajan() {
	for (int i = 1; i <= n; ++i) {
    	if (!number[i])	dfs(i);
    }
}
```

#### 割点

当一个点是割点，需要满足的两个条件

**1)** u is root of DFS tree and it has at least two children. 

**2)** u is not root of DFS tree and it has a child v such that no vertex in subtree rooted with v has a back edge to one of the ancestors (in DFS tree) of u.

```c++
void dfs(int u, int fa) {
	low[u] = number[u] = ++cnt;
	int v, child = 0;
	for (int i = head[u]; i; i = e[i].nex) {
		v = e[i].idx;
		if (!number[v]) {
			dfs(v, u);
			low[u] = min(low[u], low[v]);
			child++;
			if (low[v] >= number[u])	scc[u]++;
		} else if (number[v] < number[u] && v != fa) {
			low[u] = min(low[u], number[v]);
		}
	}

	if (child == 1 && fa == -1)	scc[u] = 0;
}
```

在该程序退出之后，如果scc[idx] != 0，那么该点就是割点

### LCA 离线 O(n)

树上任意两点之间的距离

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <vector>
#include <algorithm>
using namespace std;
const int MAX = 4e4 + 5;
int head[MAX], cnt, fa[MAX], n, q, d[MAX];
bool vis[MAX];
vector<pair<int, int> >query[MAX];
vector<pair<int, int> >ans;
struct Edge {
    int to, nex, cost;
}e[MAX<<1];
void add(int u, int v, int cost) {
    e[++cnt].to = v;
    e[cnt].nex = head[u];
    e[cnt].cost = cost;
    head[u] = cnt;
}
void init() {
    ans.clear();
    memset(head, 0, sizeof(head));
    memset(d, 0, sizeof(d));
    memset(vis, 0, sizeof(vis));
    for (int i = 1; i <= n; ++i)    {
        fa[i] = i;
        query[i].clear();
    }
    cnt = 0;
}
int find(int u) {
    return fa[u] == u? u : fa[u] = find(fa[u]);
}
void unit(int u, int v) {
    u = find(u);
    v = find(v);
    fa[v] = u;
}
void dfs1(int u, int fa) {
    int v;
    for (int i = head[u]; i; i = e[i].nex) {
        v = e[i].to;
        if (v != fa) {
            d[v] = d[u] + e[i].cost;
            dfs1(v, u);
        }
    }
}
void dfs2(int u, int fa) {
    int v;
    for (int i = head[u]; i; i = e[i].nex) {
        v = e[i].to;
        if (!vis[v] && v != fa) {
            dfs2(v, u);
            vis[v] = 1;
            unit(u, v);
        }
    }

    int len = query[u].size();
    pair<int, int> now;
    for (int i = 0; i < len; ++i) {
        now = query[u][i];
        if (vis[now.first])     {
            ans.push_back(make_pair(now.second, d[now.first] + d[u] - 2*d[find(now.first)]));
            // cout << u << ' ' << now.first << ' ' << find(now.first) << endl;
        }
    }
}
int main() {
    // freopen("input.txt", "r", stdin);
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T, u, v, cost; cin >> T;
    while (T--) {
        cin >> n >> q;
        init();
        for (int i = 1; i < n; ++i) {
            cin >> u >> v >> cost;
            add(u, v, cost);
            add(v, u, cost);
        }
        for (int i = 1; i <= q; ++i) {
            cin >> u >> v;
            query[u].push_back(make_pair(v, i));
            query[v].push_back(make_pair(u, i));
        }
        dfs1(1, -1);
        dfs2(1, -1);
        sort(ans.begin(), ans.end());
        for (int i = 0; i < q; ++i) cout << ans[i].second << '\n';
        // cout << '\n';
    }
}
```



### Hungarian O(E$\cdot$V)

* 建图的时候只需要建立从左往右的点即可
* 在for循环中也只需要遍历左边的点即可
* 左右两边的点，对应的标记不可以相等

```c++
int match[MAX], vis[MAX];
bool dfs(int now) {
	vis[now] = 1;
	int v;
	for (int i = head[now]; i; i = e[i].nex) {
		v = e[i].to;
		if (match[v] == -1 || !vis[match[v]] && dfs(match[v])) {
			match[now] = v;
			match[v] = now;
			return true;
		}
	}
	return false;
}
int hungarian() {
	int ans = 0;
	memset(match, -1, sizeof(match));
	for (int i = 1; i <= n; ++i) {
		if (match[i] == -1) {
			memset(vis, 0, sizeof(vis)); // 可以使用技巧优化掉这个n
			if (dfs(i))	++ans;
		}
	}
	return ans;
}
```

### 欧拉回路 & 欧拉路径  O(V$\cdot $ logV) 

欧拉路径 & 欧拉回路

算法的主体是一个简单的dfs，如果使用邻接矩阵来存储图，将会达到$O(n^2)$的复杂度，而使用multiset来存储图，可以达到$O(nlgn)$的复杂度

欧拉路径的存在条件：只有两个结点的度数为奇数

欧拉回路的存在条件：整个图联通，所有结点的度数为偶数

如果是第一种情况，那么在调用dfs时应该从两个奇数度结点之一调用；后者的话则任意

一般来说，题目里会要求打印字典序最小的路径，所以一般都是选择最小度开始打印

```c++
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <set>
#include <stack>
using namespace std;
const int MAX = 3000;
multiset<int>G[300];
int n, degree[MAX];
stack<char>ans;
void dfs(int u) {
    char v;
    char c =u;
    for (auto x = G[u].begin(); x != G[u].end(); x = G[u].begin()) {
        v = *x;
        G[u].erase(x);
        G[v].erase(G[v].find(u));
        dfs(v);
    }
    ans.push(u);
}
int main() {
    scanf("%d", &n);
    char s[3];
    char u, v;
    for (int i = 1; i <= n; ++i) {
        scanf("%s", s);
        u = s[0]; v = s[1];
        degree[u] += 1;
        degree[v] += 1;
        G[u].insert(v);
        G[v].insert(u);
    }
    
    int cnt = 0, idx = 0;
    for (int i = 1; i <= 300; ++i) if (degree[i]&1) {
        ++cnt;
        if (!idx)   idx = i;
    }
    
    if (cnt && cnt != 2)    {
        printf("No Solution\n");
        return 0;
    }
    
    if (!cnt) for (int i = 'A'; i <= 'z'; ++i) if (degree[i])   {idx = i; break;}
    
    dfs(idx);
    if (ans.size() != n + 1) printf("No Solution\n");
    else {
        while (!ans.empty())  {
            printf("%c", ans.top()); ans.pop();
        }
    }
    
}

```

### 拓扑排序  O(E + V)

结果中如果某些结点的度数不为0，那么该点就一定位于某个环中

```c++
void topoSort() {
    queue<int>q;
    int u, v;
    for (int i = 1; i <= n; ++i) if (!degree[i]) {
        q.push(i);
    }

    while (!q.empty()) {
        u = q.front(); q.pop();
        for (int i = head[u]; i; i = e[i].nex) {
            v = e[i].to;
            degree[v]--;
            if (!degree[v]) q.push(v);
        }
    }
    
}
void input() {
    cnt = 0;
    memset(head, 0, sizeof(head));
    int u, v;
    memset(degree, 0, sizeof(degree));
    
    for (int i = 1; i <= m; ++i) {
        scanf("%d%d", &u, &v);
        ++u; ++v;
        add(u, v);
        degree[v]++;
    }

}
```

### spfa判负环

spfa寻找图中负环 & 差分约束系统

有两种方式可以寻找负环

建图的方式：

- $a - b \le c$   连接 b->a   cost = c
- $a - b \ge c$   -> $b - a \le -c$ 连接 a->b  cost = -c

第一种是复杂度不是很好的bfs，但是好写好理解

```c++
bool spfa(int t) {
    queue<int>q;
    q.push(t);
    d[t] = 0; vis[t] = true;
    int u, v;
    while (!q.empty()) {
        u = q.front(); q.pop(); vis[u] = false;
        for (int i = head[u]; i; i = e[i].nex) {
            v = e[i].to;
            if (d[v] > d[u] + e[i].cost) {
                d[v] = d[u] + e[i].cost;
                if (!vis[v]) {
                    ++in[v]; vis[v] = true; q.push(v);
                    if (in[v] == n + 1) return false;
                }
            }
        }
    }
    return true;
}
int main() {
    input();
    for (int i = 1; i <= n; ++i) d[i] = 1<<30;
    for (int i = 1; i <= n; ++i) if (d[i] == (1<<30)) {
        if (!spfa(i))   {printf("No\n"); return 0;}
    }
    printf("Yes\n");
    return 0;
}
```

第二种是复杂度比较好的dfs

```c++
bool spfa(int u) {
    vis[u] = 1;
    int v;
    for (int i = head[u]; i; i = e[i].nex) {
        v = e[i].to;
        if (d[v] > d[u] + e[i].cost) {
            if (vis[v]) return false;
            d[v] = d[u] + e[i].cost;
            if (!spfa(v))    return false;
        }
    }
    vis[u] = 0;
    return true;
}
int main() {
    input();
    for (int i = 1; i <= n; ++i) {
        d[i] = 0;
        if (!spfa(i))   return 0 * printf("No\n");
    }
    printf("Yes\n");
}
```



### Dijkstra + 堆优化

很神奇的一个地方，如果pq里面的元素是`pair<int, int>q`那么第一个元素按照从小到大排列

而如果是`pair<long long, int> q`那么第一个元素按照从大到小排列

```c++
void dijkstra() {    
    priority_queue<pair<long long, int>, vector<pair<long long, int> >, greater<pair<long long, int> > >q;
    for (int i = 1; i <= n; ++i) d[i] = 1LL<<50;
    d[1] = 0;
    q.push(make_pair(0, 1));
    pair<long long, int> now;
    int u, v;
    while (!q.empty()) {
        now = q.top(); q.pop();
        u = now.second;

        if (vis[u] || d[u] < now.first)   continue;
        vis[u] = true;
        
        if (u == n) return ;
        for (int i = head[u]; i; i = e[i].nex) {
            v = e[i].to;
            if (!vis[v] && d[v] > d[u] + e[i].cost) {

                d[v] = d[u] + e[i].cost;
                q.push(make_pair(d[v], v));
                pre[v] = u;
            }
        }
    }
}
```



### K短路 (A*算法)

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <algorithm>
#include <queue>
#include <vector>
using namespace std;
typedef long long ll;
inline int read(){
    char c=getchar(); int x=0,f=1;
    while(c<'0'||c>'9') {if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9') {x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int MAX = 1e3 + 5;
vector<pair<int, int> >G[MAX], G_[MAX];
int n, m, s, e, k, t, d[MAX], vis[MAX];
void input() {
    s = read(); e = read(); k = read(); t = read();

    for (int i = 1; i <= n; ++i) {G[i].clear(); G_[i].clear();}
    for (int i = 1, u, v, c; i <= m; ++i) {
        u = read(); v = read(); c = read();
        G[u].push_back(make_pair(v, c));
        G_[v].push_back(make_pair(u, c));
    }
}
void dijkstra() {    
    priority_queue<pair<int, int> >q;

    for (int i = 1; i <= n; ++i) d[i] = 1<<30, vis[i] = false;
    d[e] = 0;
    q.push(make_pair(0, e));
    pair<int, int> now;
    int u, v, len;
    while (!q.empty()) {
        now = q.top(); q.pop();
        u = now.second;

        if (vis[u] || d[u] < now.first)   continue;
        vis[u] = true;
        len = G_[u].size();
        for (int i = 0; i < len; ++i) {
            v = G_[u][i].first;
            if (!vis[v] && d[v] > d[u] + G_[u][i].second) {
                d[v] = d[u] + G_[u][i].second;
                q.push(make_pair(d[v], v));
            }
        }
    }
}
struct Node {
    int g, u;
    ll h;
    Node(ll a = 0, int b = 0, int c = 0) {
        h = a; g = b; u = c;
    }
    bool operator < (const Node b) const {
        return h + g > b.h + b.g;
    }
}now;

priority_queue<Node>q;
int solve() {
    while (!q.empty()) q.pop();

    q.push(Node(0, d[s], s));
    memset(vis, 0, sizeof(vis));

    int len, num = 0, u, v;
    while (!q.empty()) {
        now = q.top(); q.pop(); u = now.u;
        vis[u]++;
        if (now.u == e) ++num;
        if (num == k)   return now.h;
        if (now.h > t)  continue;

        len = G[u].size();
        if (vis[u] <= k ) for (int i = 0; i < len; ++i) {
            v = G[u][i].first;
            q.push(Node(G[u][i].second + now.h, d[v], v));
        }
    }

    return -1;
}
int main() {
    while (scanf("%d%d", &n, &m) != EOF) {
        input();
        dijkstra();
        if ((d[s] == (1<<30)) || d[s] > t) {printf("Whitesnake!\n"); continue;}


        int now = solve();
        if (now == -1 || now > t) printf("Whitesnake!\n");
        else printf("yareyaredawa\n");
    }
}
```



# 网络流

### Dinic

* 当添加汇点时，一定要保证在dfs和bfs的for循环中要遍历到那个点
* 要求输出配对方案时，使用邻接矩阵存储，初始为-1，最后看那些边为0即可
* 输出方案时，记得要考虑反向边！否则可能会RE

```c++
#include <iostream>
#include <cstring>
#include <string>
#include <algorithm>
#include<queue>
const int MAX = 1e4 + 5;
const int MAXM = 1e5 + 5;
const int INF = 1<<30;
using namespace std;
int head[MAX], cnt, level[MAX], n, m, s, t;
struct Edge {
    int to, nex, flow;
}e[MAXM<<1];
void add(int u, int v, int c) {
    e[++cnt] = (Edge) {v, head[u], c};
    head[u] = cnt;
    e[++cnt] = (Edge) {u, head[v], 0};
    head[v] = cnt;
}
void init() {
    cnt = -1;
    memset(head, -1, sizeof(head));
}
bool bfs() {
    queue<int>q;
    memset(level, 0, sizeof(level));
    level[s] = 1;
    q.push(s);
    int u, v;
    while (!q.empty()) {
        u = q.front(); q.pop();
        for (int i = head[u]; i != -1; i = e[i].nex) {
            v = e[i].to;
            if (!level[v] && e[i].flow > 0) {
                level[v] = level[u] + 1;
                q.push(v);
                if (v == t) return true;
            }
        }
    }

    return false;
}
int dfs(int u, int Min) {
    if (!Min || u == t) return Min;

    int v, flow = 0, now;
    for (int i = head[u]; i != -1; i = e[i].nex) {
        v = e[i].to;
        if (level[v] == level[u] + 1 && e[i].flow) {
            now = dfs(v, min(Min, e[i].flow));

            flow += now;
            e[i].flow -= now;
            e[i^1].flow += now;
            Min -= now;
        }
    }
    if (!flow)   level[u] = 0;
    return flow;
}
int main() {
    // freopen("input.txt", "r", stdin);

    init();
    scanf("%d%d%d%d", &n, &m, &s, &t);
    int u, v, c;
    while (m--) {
        scanf("%d%d%d", &u, &v, &c);
        add(u, v, c);
    }
    int ans = 0;
    while (bfs()) ans += dfs(s, INF);
    printf("%d\n", ans);
}
```



### 最小费用流

* 如果是多组数据，记得对h数组初始化

```c++
#include <iostream>
#include <cstring>
#include <string>
#include <algorithm>
#include <queue>
#include <vector>
#define INF 0x3f3f3f3f
#define P pair<int, int>
using namespace std;
const int MAX = 5e3 + 5;
const int MAXM = 5e4 + 5;
struct Edge {
    int from, to, nex, flow, cost;
    Edge(){}
    Edge(int a, int b, int c, int d, int e): from(a), to(b), nex(c), flow(d), cost(e) {}
}e[MAXM<<3];
int head[MAX], cnt, dis[MAX], n, m, s, t;
inline void add(int u, int v, int flow, int cost) {
    e[++cnt] = Edge(u, v, head[u], flow, cost);
    head[u] = cnt;
    e[++cnt] = Edge(v, u, head[v], 0, -cost);
    head[v] = cnt;
}
int flow, cost, h[MAX], pre[MAX];
void init() {
    cnt = -1;
    memset(head, -1, sizeof(head));
}
void minCostFlow() {
    pre[s] = -1;
    int u, v; P now;
    while (true) {
        memset(dis, INF, sizeof(dis));
        priority_queue<P, vector<P>, greater<P> >q;
        q.push(P(0, s));
        dis[s] = 0;
        while (!q.empty()) {
            now = q.top(); q.pop();
            if (dis[now.second] < now.first)    continue;

            u = now.second;
            for (int i = head[u]; i != -1; i = e[i].nex) {
                v = e[i].to;
                if (e[i].flow > 0 && dis[v] > dis[u] + e[i].cost + h[u] - h[v]) {
                    dis[v] = dis[u] + e[i].cost + h[u] - h[v];
                    q.push(P(dis[v], v));
                    pre[v] = i;
                }
            }
        }

        if (dis[t] == INF)  break;
        for (int i = 1; i <= n; ++i)    h[i] += dis[i];

        int Min = INF;
        for (int i = pre[t]; i != -1; i = pre[e[i].from]) Min = min(Min, e[i].flow);
        for (int i = pre[t]; i != -1; i = pre[e[i].from]) {e[i].flow -= Min; e[i^1].flow += Min;}
        flow += Min;
        cost += Min * h[t];
    }

}
inline int read()
{
    int x=0;
    char c=getchar();
    bool flag=0;
    while(c<'0'||c>'9'){if(c=='-')flag=1;    c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-'0';c=getchar();}
    return flag?-x:x;
}
int main() {
    init();
    // scanf("%d%d%d%d", &n, &m, &s, &t);
    n = read(); m = read(); s = read(); t = read();
    for (int i = 1, u, v, flow, cost; i <= m; ++i) {
        // scanf("%d%d%d%d", &u, &v, &flow, &cost);
        u = read(); v = read(); flow  = read(); cost  = read();
        add(u, v, flow, cost);
    }

    minCostFlow();
    printf("%d %d\n", flow, cost);
}
```



### 最小割

```c++
#include <iostream>
#include <queue>
#include <cstdio>
#include <cstring>
#include <string>
#include <algorithm>
#include <vector>
typedef long long ll;
#define INF 0x3f3f3f3f
#define P pair<int, int>
using namespace std;
const int MAX = 105;
struct Edge {
    int to, nex, flow;
}E[MAX*MAX*2], e[MAX*MAX*2];
int head[MAX], cnt, level[MAX], n, m, s, t;
inline void add(int u, int v, int flow) {
    E[++cnt] = (Edge) {v, head[u], flow};
    head[u] = cnt;
    E[++cnt] = (Edge) {u, head[v], 0};
    head[v] = cnt;
}
void init() {
    cnt = -1; memset(head, -1, sizeof(head));
}
bool bfs() {
    queue<int>q;
    q.push(s);
    memset(level, 0, sizeof(level));
    level[s] = 1;
    int u, v;
    while (!q.empty()) {
        u = q.front(); q.pop();
        for (int i = head[u]; i != -1; i = e[i].nex) {
            v = e[i].to;
            if (!level[v] && e[i].flow > 0) {
                level[v] = level[u] + 1;
                q.push(v);
                if (v == t) return true;
            }
        }
    }
    return false;
}
ll dfs(int u, int Min) {
    if (!Min || u == t) return Min;

    int v;
    ll ans = 0, flow;
    for (int i = head[u]; i != -1; i = e[i].nex) {
        v = e[i].to;
        if (level[v] == level[u] + 1 && e[i].flow > 0) {
            flow = dfs(v, min(Min, e[i].flow));

            ans += flow;
            e[i].flow -= flow;
            e[i^1].flow += flow;
            Min -= flow;
        }
    }
    if (!ans)   level[u] = 0;
    return ans;
}
ll Dinic(int idx) {
    memcpy(e, E, sizeof(E));

    if (idx != -1)  e[idx].flow = 0;
    ll ans = 0;
    while (bfs())   ans += dfs(s, INF);
    return ans;
}

vector<P> q;
bool cmp(P a, P b) {
    return a.first > b.first;
}
int main() {
    scanf("%d%d", &n, &m); s = 1; t = n; init();
    for (int i = 1, u, v, flow; i <= m; ++i) {
        scanf("%d%d%d", &u, &v, &flow);
        add(u, v, flow);
    } 

    //注意这里不能把反向边加进去！不然每一条反向边都会认为是割边！
    for (int i = 0; i <= cnt; i += 2) q.push_back(P(E[i].flow, i));
    sort(q.begin(), q.end(), cmp);
    
    int ans = 0, len = q.size();
    ll flow = Dinic(-1), ans1 = flow, now;

    // cout << q[0].first << endl;
    for (int i = 0; i < len; ++i) {
        now = Dinic(q[i].second);
        if (now + E[q[i].second].flow == flow) {
            flow = now;
            E[q[i].second].flow = 0;
            ++ans;
        }
    }

    printf("%lld %d\n", ans1, ans);
}
```



# 计算几何

### Graham's Scan 求凸包

1. 找到最下边的点，如果有多个点在同一y值，那么选取最左边的点

2. 以找到的点为参考点，将所有的点按照极角进行排序，方法是使用叉积

   我第一次写板子的时候没有处理好点的起点下标，果然还是从1开始比较人道

3. 使用单调栈的思路维护一个栈，该栈中最后剩下的点即为凸包

```c++
#include <iostream>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <string>
#include <algorithm>
using namespace std;
const double PI = acos(-1.0);
const double EPS = 1e-6;
const int MAX = 1005;
struct Point {
	int x, y;
	void in() {
		scanf("%d%d", &x, &y);
	}
}p[MAX];
int n, L;
int xmult(Point p0, Point p1, Point p2) {
	return (p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y);
}
double dis(Point a, Point b) {
	double dx = a.x - b.x;
	double dy = a.y - b.y;
	return sqrt(dx * dx + dy * dy);
}
bool cmpAngle(Point a, Point b) {
	int temp = xmult(p[1], a, b);
	if (temp > 0)	return true;
	else if (temp == 0 && dis(p[1], a) < dis(p[1], b))	return true;
	return false;
}
void in() {
	scanf("%d%d", &n, &L);
	p[1].in();
	int low = 1;
	for (int i = 2; i <= n; ++i) {
		p[i].in();
		if (p[i].y < p[low].y || (p[i].y == p[low].y && p[i].x < p[low].x))
			low = i;
	}
	if (low != 1)	swap(p[1], p[low]);
	sort(p + 2, p + 1 + n, cmpAngle);
}
int s[MAX], top = 0;
void graham() {
	double ans = 0;
	s[0] = 1;
	s[1] = 2;
	top = 2;
	for (int i = 3; i <= n; ++i) {
		while (top >= 2 && xmult(p[s[top - 2]], p[s[top - 1]], p[i]) <= 0)	--top;
		s[top++] = i;
	}
}
```



# 中缀表达式求值

```c++
#include <iostream>
#include <cstdio>
#include <string>
#include <algorithm>
#include <queue>
#include <stack>
#include <cstring> 
using namespace std;
typedef long long ll;
const int MAX = 110;
ll d[MAX][MAX][2];
stack<int>ss;
char s[MAX];
bool vis[MAX][MAX][2];
int A[MAX], len;
void init() {
    memset(vis, 0, sizeof(vis));
    memset(A, 0, sizeof(A));
    memset(d, 0, sizeof(d));
}
ll dfs(int l, int r, int flag) {
    if (s[l] == '(' && A[l] == r)   return dfs(l + 1, r - 1, flag);
    if (vis[l][r][flag])    return d[l][r][flag];
    vis[l][r][flag] = 1;
    int cnt = 0;
    for (int i = r; i >= l; --i) {
        if (s[i] == '(')    ++cnt;
        if (s[i] == ')')    --cnt;
        if (s[i] == '+' && !cnt) {
            if (flag)   return d[l][r][1] = dfs(l, i - 1, 1) + dfs(i + 1, r, 1);
            else return d[l][r][0] = dfs(l, i - 1, 0) + dfs(i + 1, r, 0);
        } 
        if (s[i] == '-' && !cnt) {
            if (flag)   return d[l][r][1] = dfs(l, i - 1, 1) - dfs(i + 1, r, 0);
            else return d[l][r][0] = dfs(l, i - 1, 0) - dfs(i + 1, r, 1);
        }
    }

    cnt = 0;
    for (int i = r; i >= l; --i) {
        if (s[i] == '(')    ++cnt;
        if (s[i] == ')')    --cnt;
        if (s[i] == '*' && !cnt) {
            if(flag==0)
            {
                d[l][r][0]=min(dfs(l,i-1,0)*dfs(i+1,r,0),dfs(l,i-1,1)*dfs(i+1,r,1));
                d[l][r][0]=min(d[l][r][0],dfs(l,i-1,0)*dfs(i+1,r,1));
                d[l][r][0]=min(d[l][r][0],dfs(l,i-1,1)*dfs(i+1,r,0));
            }
            else
            {
                d[l][r][1]=max(dfs(l,i-1,0)*dfs(i+1,r,0),dfs(l,i-1,1)*dfs(i+1,r,1));
                d[l][r][1]=max(d[l][r][1],dfs(l,i-1,0)*dfs(i+1,r,1));
                d[l][r][1]=max(d[l][r][1],dfs(l,i-1,1)*dfs(i+1,r,0));
            }
            return d[l][r][flag];
        }
    }

    cnt = 0;
    for (int i = l; i <= r; ++i) {
        if (s[i] == '(')    ++cnt;
        if (s[i] == ')')    --cnt;
        if (!cnt && s[i] == 'd') {
            if (flag)   return d[l][r][1] = dfs(l, i - 1, 1) * dfs(i + 1, r, 1);
            else return d[l][r][0] = dfs(l, i - 1, 0);
        }
    }

    ll sum = 0;
    for (int i = l; i <= r; ++i)    sum = sum * 10 + s[i] - '0';
    return d[l][r][flag] = sum;
}
int main() {
    while (scanf("%s", s + 1) != EOF) {
        init();
        len = strlen(s + 1);
        for (int i = 1; i <= len; ++i) if (s[i] == '(') ss.push(i);  else if (s[i] == ')') A[ss.top()] = i, ss.pop();

        printf("%lld %lld\n", dfs(1, len, 0), dfs(1, len, 1));
    }
}
```



# 对拍.sh 文件

sh xxx.sh 来执行对拍文件

```javascript
#!/bin/bash
while true; do
	./r > input
	./a < input > output.a
	./b < input > output.b
	diff output.a output.b
	if [ $? -ne 0 ] ; then break; fi
done
```



# 读入优化

在使用前可以使用`using namespace IO;` 之后使用`read()`  `print`

```c++
namespace IO{ 
    #define BUF_SIZE 100000 
    #define OUT_SIZE 100000 
    #define ll long long 
    //fread->read 

    bool IOerror=0; 
    inline char nc(){ 
        static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; 
        if (p1==pend){ 
            p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); 
            if (pend==p1){IOerror=1;return -1;} 
            //{printf("IO error!\n");system("pause");for (;;);exit(0);} 
        } 
        return *p1++; 
    } 
    inline bool blank(char ch){return ch==' '||ch=='\n'||ch=='\r'||ch=='\t';} 
    inline void read(int &x){ 
        bool sign=0; char ch=nc(); x=0; 
        for (;blank(ch);ch=nc()); 
        if (IOerror)return; 
        if (ch=='-')sign=1,ch=nc(); 
        for (;ch>='0'&&ch<='9';ch=nc())x=x*10+ch-'0'; 
        if (sign)x=-x; 
    } 
    inline void read(ll &x){ 
        bool sign=0; char ch=nc(); x=0; 
        for (;blank(ch);ch=nc()); 
        if (IOerror)return; 
        if (ch=='-')sign=1,ch=nc(); 
        for (;ch>='0'&&ch<='9';ch=nc())x=x*10+ch-'0'; 
        if (sign)x=-x; 
    } 
    inline void read(double &x){ 
        bool sign=0; char ch=nc(); x=0; 
        for (;blank(ch);ch=nc()); 
        if (IOerror)return; 
        if (ch=='-')sign=1,ch=nc(); 
        for (;ch>='0'&&ch<='9';ch=nc())x=x*10+ch-'0'; 
        if (ch=='.'){ 
            double tmp=1; ch=nc(); 
            for (;ch>='0'&&ch<='9';ch=nc())tmp/=10.0,x+=tmp*(ch-'0'); 
        } 
        if (sign)x=-x; 
    } 
    inline void read(char *s){ 
        char ch=nc(); 
        for (;blank(ch);ch=nc()); 
        if (IOerror)return; 
        for (;!blank(ch)&&!IOerror;ch=nc())*s++=ch; 
        *s=0; 
    } 
    inline void read(char &c){ 
        for (c=nc();blank(c);c=nc()); 
        if (IOerror){c=-1;return;} 
    } 
    //fwrite->write 
    struct Ostream_fwrite{ 
        char *buf,*p1,*pend; 
        Ostream_fwrite(){buf=new char[BUF_SIZE];p1=buf;pend=buf+BUF_SIZE;} 
        void out(char ch){ 
            if (p1==pend){ 
                fwrite(buf,1,BUF_SIZE,stdout);p1=buf; 
            } 
            *p1++=ch; 
        } 
        void print(int x){ 
            static char s[15],*s1;s1=s; 
            if (!x)*s1++='0';if (x<0)out('-'),x=-x; 
            while(x)*s1++=x%10+'0',x/=10; 
            while(s1--!=s)out(*s1); 
        } 
        void println(int x){ 
            static char s[15],*s1;s1=s; 
            if (!x)*s1++='0';if (x<0)out('-'),x=-x; 
            while(x)*s1++=x%10+'0',x/=10; 
            while(s1--!=s)out(*s1); out('\n'); 
        } 
        void print(ll x){ 
            static char s[25],*s1;s1=s; 
            if (!x)*s1++='0';if (x<0)out('-'),x=-x; 
            while(x)*s1++=x%10+'0',x/=10; 
            while(s1--!=s)out(*s1); 
        } 
        void println(ll x){ 
            static char s[25],*s1;s1=s; 
            if (!x)*s1++='0';if (x<0)out('-'),x=-x; 
            while(x)*s1++=x%10+'0',x/=10; 
            while(s1--!=s)out(*s1); out('\n'); 
        } 
        void print(double x,int y){ 
            static ll mul[]={1,10,100,1000,10000,100000,1000000,10000000,100000000, 
                1000000000,10000000000LL,100000000000LL,1000000000000LL,10000000000000LL, 
                100000000000000LL,1000000000000000LL,10000000000000000LL,100000000000000000LL}; 
            if (x<-1e-12)out('-'),x=-x;x*=mul[y]; 
            ll x1=(ll)floor(x); if (x-floor(x)>=0.5)++x1; 
            ll x2=x1/mul[y],x3=x1-x2*mul[y]; print(x2); 
            if (y>0){out('.'); for (size_t i=1;i<y&&x3*mul[i]<mul[y];out('0'),++i); print(x3);} 
        } 
        void println(double x,int y){print(x,y);out('\n');} 
        void print(char *s){while (*s)out(*s++);} 
        void println(char *s){while (*s)out(*s++);out('\n');} 
        void flush(){if (p1!=buf){fwrite(buf,1,p1-buf,stdout);p1=buf;}} 
        ~Ostream_fwrite(){flush();} 
    }Ostream; 
    inline void print(int x){Ostream.print(x);} 
    inline void println(int x){Ostream.println(x);} 
    inline void print(char x){Ostream.out(x);} 
    inline void println(char x){Ostream.out(x);Ostream.out('\n');} 
    inline void print(ll x){Ostream.print(x);} 
    inline void println(ll x){Ostream.println(x);} 
    inline void print(double x,int y){Ostream.print(x,y);} 
    inline void println(double x,int y){Ostream.println(x,y);} 
    inline void print(char *s){Ostream.print(s);} 
    inline void println(char *s){Ostream.println(s);} 
    inline void println(){Ostream.out('\n');} 
    inline void flush(){Ostream.flush();}
    #undef ll 
    #undef OUT_SIZE 
    #undef BUF_SIZE 
};
```



# 注意事项

1. 读题！读题！读题！有没有地方是理解错了的！

2. Debug  -> 看看有没有什么变量拼错了，搞成了另外一个变量 !!!

3. 链式前向星，注意开双倍大小!! 在二分图建模时可能会是平方大小!!!

   初始化！多组数据每次要重新设置cnt以及head[]

4. 输出的格式对不对!!! "YES"  "NO"

5. zkw线段树，传入的区间是左闭右开

6. 线段树出现RE的调试方法
   * 将线段树数组开成 `MAX<<4`
   * 将线段树的使用容量每次都开到最大
   * 保证线段树的左区间最小为1

7. Java 类的名字是`Main`，函数的名字是`main`

8. `cin`和`scanf`不可混用
