[TOC]

# JAVA大数

### 使用大整数的compareTo()函数

```java
import java.util.*;
import java.math.*;
import java.lang.*;
public class Main{
    public static void main(String[] args) {
        Scanner cin = new Scanner(System.in);
        BigInteger []ans = new BigInteger[2005];
        ans[1] = BigInteger.ONE;
        ans[2] = BigInteger.ONE.add(ans[1]);
        for(int i = 3; i < 2000; ++i){
            ans[i] = ans[i - 1].add(ans[i - 2]);
            if(ans[i].toString().length() > 100)   {
                break;
            }
        }
        BigInteger a, b;
        while(true) {
            a = cin.nextBigInteger();
            b = cin.nextBigInteger();
            if(a.compareTo(BigInteger.ZERO) == 0 && b.compareTo(BigInteger.ZERO) == 0) break;
            int c = 0;
            for(int i = 1; i <= 480; ++i)
                if(a.compareTo(ans[i]) <= 0 && ans[i].compareTo(b) <= 0) ++c;
            System.out.println(c);
        }
    }
}
```

### 使用大浮点数的内建方法

```java
import java.util.*;
import java.math.*;
import java.lang.*;
public class Main{
    public static void main(String[] args) {
        BigDecimal ans;
        int n;
        Scanner cin = new Scanner(System.in);
        while(cin.hasNext()) {
            ans = cin.nextBigDecimal();
            n = cin.nextInt();
            String a = ans.pow(n).stripTrailingZeros().toPlainString();//去除末尾多余的零
            while(a.charAt(0) == '0')  a = a.substring(1);
            System.out.println(a);
        }
    }
}
```

### 使用自带的Miller Rabin方法

```java
public class Main {
    public static void main(String[] args) {
        InputReader reader = new InputReader();
        PrintWriter out = new PrintWriter(System.out);
        int t = reader.nextInt();
        while (t-- > 0) {
            long n = reader.nextLong();
            long half = n / 2;
            int get = (int) (half % 10);
            // if (isPrime(n - 5)) {
            // if (Miller_Rabin(n - 5)) {
            if (BigInteger.valueOf(n - 5).isProbablePrime(5)) {
                out.println(5 + " " + (n - 5));
                continue;
            }
            while (half > 0) {
                // System.out.println(half);
                if (get == 1 || get == 7 || get == 9 || get == 3) {
                    // if (isPrime(get)) {
                    // if (Miller_Rabin(half)) {
                    if (BigInteger.valueOf(half).isProbablePrime(5)) {
                        long half2 = n - half;
                        long get2 = half2 % 10;
                        if (get2 == 1 || get2 == 7 || get2 == 9 || get2 == 3) {
                            // if (isPrime(half2)) {
                            // if (Miller_Rabin(half2)) {
                            if (BigInteger.valueOf(half2).isProbablePrime(5)) {
                                out.println(half + " " + half2);
                                break;
                            }
                        }
                    }
                }
                half--;
                get = (int) (half % 10);
            }
        }
        out.close();
    }
}
```



### 大数乘除

```java
import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.math.BigInteger;
import java.util.Scanner;

public class Main {
	public static void main(String[] args) throws FileNotFoundException {
		Scanner cin = new Scanner(new File("input.txt"));
		PrintWriter print = new PrintWriter(new File("output.txt"));
		int n;
		BigInteger []t = new BigInteger[307];
		BigInteger []num = new BigInteger[307];
		num[3] = BigInteger.valueOf(2);
		num[6] = BigInteger.valueOf(9);
		t[12] = BigInteger.valueOf(17);
		num[9] = BigInteger.valueOf(38);
		for(int i = 12;i<=300;i+=3){
			if((i%2)==0){
				num[i] = num[i-3].multiply(BigInteger.valueOf(4)).subtract(t[i]);
				t[i+6] = t[i].multiply(BigInteger.valueOf(4)).add(BigInteger.valueOf(21));
			}else {
				num[i] = num[i-3].multiply(BigInteger.valueOf(4)).add(BigInteger.valueOf(2));
			}
		}
		while(cin.hasNext()){
			n = cin.nextInt();
			print.println(num[n]);
		}
		cin.close();
		print.close();
	}
}
```

### 使用String初始化BigInteger

```java
BigInteger now = new BigInteger("100000");
```



# 矩阵模板(注意在需要的地方改long long)

```c++
struct Mat{
    int row, col ,N[25][25];
    Mat(int row = 0 , int col = 0){
        memset(N, 0, sizeof(N));
        this -> row = row;
        this -> col = col;
    }
    Mat operator * (const Mat B) const {
        Mat A(row, B.col);
        for(int i = 0 ;i < row; i ++)
            for(int k = 0 ; k < col; k ++)
                for(int j = 0 ; j < B.col; j++){
                    A.N[i][j] = A.N[i][j] + N[i][k] * B.N[k][j] ;
                }
        return A;
    }
    Mat operator ^ (int x) const {
        Mat A(row,row) , temp = *this;
        for(int i = 0 ; i < row; i ++)  A.N[i][i] = 1;
        while(x){
            if(x & 1)   A = A * temp;
            temp = temp * temp;
            x>>= 1;
        }
        return A;
    }
};
```

# KMP

```c++
void getNext(string &a) {
    int i = 0, j = -1, len = a.size();
    Next[0] = -1;
    while(i < len) {
        if(j == -1 || a[i] == a[j]) {
            Next[++i] = ++j;
        } else {
            j = Next[j];
        }
    }
}

int KmpSearch(char* s, char* p)
{
	int i = 0;
	int j = 0;
	int sLen = strlen(s);
	int pLen = strlen(p);
	while (i < sLen && j < pLen)
	{
		//①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++    
		if (j == -1 || s[i] == p[j])
		{
			i++;
			j++;
		}
		else
		{
			//②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]    
			//next[j]即为j所对应的next值      
			j = Next[j];
		}
	}
	if (j == pLen)
		return i - j;
	else
		return -1;
}
```

# 递归版线段树

### 区间染色

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <vector>
using namespace std;
const int N = 8e4 + 5;
const int MAX = 8e4 + 1;
int color[N];
struct Node {
	int color, time;
}t[N<<1];
void build() {
	for(int i = 1; i < (N<<1); ++i)
		t[i].color = -1, t[i].time = 0;
}
void update(int l, int r, int color, int time) {
	for(l += MAX, r += MAX; l < r; l >>= 1, r >>= 1) {
		if(l&1)	t[l].color = color, t[l++].time = time;
		if(r&1)	t[--r].color = color, t[r].time = time;
	}
}
void push() {
	for(int i = 1; i < MAX; ++i) {
		if(t[i].time > t[i<<1].time)	t[i<<1].time = t[i].time, t[i<<1].color = t[i].color;
		if(t[i].time > t[i<<1|1].time)	t[i<<1|1].time = t[i].time, t[i<<1|1].color = t[i].color;
	}
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int m, l, r, c;
	while(cin >> m) {
		build();
		for(int i = 1; i <= m; ++i) {
			cin >> l >> r >> c;
			update(l, r, c, i);
		}
		push();
		memset(color, 0, sizeof(color));
		int now = -1;
		for(int i = 0 + MAX; i <= MAX + MAX; ++i) {
			if(now == -1) {
				if(t[i].color == -1)	continue;
				now = t[i].color;
			} else {
				if(t[i].color == now)	continue;
				else {
					color[now]++;
					now = t[i].color;
				}
			}
		}

		for(int i = 0; i < MAX; ++i)
			if(color[i])	cout << i << " " << color[i] << '\n';
		cout << '\n';
	}
}
```

### 懒惰标记

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <cmath>
#include <vector>
using namespace std;
const int MAX = 2e5 + 5;
struct Node {
	bool type;//if all values in this segment are '1'
	long long val;
}t[MAX];
int n, m;
void build() {
	for(int i = n - 1; i > 0; --i) {
		if(t[i<<1].type && t[i<<1|1].type)	t[i].type = 1;
		else	t[i].type = 0;
		t[i].val = t[i<<1].val + t[i<<1|1].val;
	}
}
void up(int x) {
	while(x > 1) {
		t[x>>1].val = t[x].val + t[x^1].val;
		x >>= 1;
	}
}
long long deal(int x) {
	if(t[x].type == 1)	return t[x].val;
	if(x >= n) {
//		cout << x << " " << t[x].val << " -> " << (int)sqrt(t[x].val) << endl;
		t[x].val = sqrt(t[x].val);
//		cout << "now : " << t[x].val << endl;
		if(t[x].val <= 1)	t[x].type = 1;
		up(x);
		return t[x].val;
	}
	if(t[x<<1].type != 1)	deal(x<<1);
	if(t[x<<1|1].type != 1)	deal(x<<1|1);

	t[x].val = t[x<<1].val + t[x<<1|1].val;
	if(t[x<<1].type && t[x<<1|1].type)	t[x].type = 1;
	up(x);
	return t[x].val;
}
void update(int l, int r) {
	for(l += n, r += n; l < r; l >>= 1, r >>= 1) {
		if(l&1) deal(l++);
		if(r&1)	deal(--r);
	}
}
long long query(int l, int r) {
	long long ans = 0;
	for(l += n, r += n; l < r; l >>= 1, r >>= 1) {
		if(l&1)	{
			ans += t[l++].val;
		}
		if(r&1)	{
			ans += t[--r].val;
		}
	}
	return ans;
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int cnt = 1;
	// freopen("input", "r", stdin);
	// freopen("output.a", "w", stdout);
	while(cin >> n) {
		cout << "Case #" << cnt++ << ":\n";
		for(int i = 0; i < n; ++i) {
			cin >> t[i + n].val;
			if(t[i + n].val <= 1)	t[i + n].type = 1;
			else	t[i + n].type = 0;
		}
		build();
		cin >> m;
		int type, l, r;
		while(m--) {
			cin >> type >> l >> r;
			if(l > r)	swap(l, r);
			if(type == 0)	update(l - 1, r);
			else	cout << query(l - 1, r) << '\n';
		}
		cout << '\n';
	}
}
```

### 懒惰标记 区间修改 求最大值

```java
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
using namespace std;
struct Node {
	long val, lazy;
	int l, r;
	struct Node* L, *R;
};
const int MAX = 1e5 + 5;
long a[MAX];
int n;
long max(long a, long b) {
	if (a > b)	return a;
	return b;
}
void build(Node*& t, int l, int r) {
	t->l = l;
	t->r = r;
	t->lazy = 0;
	if (l == r) {
		t->val = a[l];
		return ;
	}

	t->L = (Node*)malloc(sizeof(Node));
	t->R = (Node*)malloc(sizeof(Node));
	int mid = (l + r) >> 1;
	build(t->L, l, mid);
	build(t->R, mid + 1, r);

	t->val = max(t->L->val, t->R->val);
}

void update(Node*& t, int l, int r, long add) {
	if(l == t->l && r == t->r) {
		t->val += add;
		t->lazy += add;
		return ;
	}

	int mid = (t->r + t->l) >> 1;
	if (r <= mid)	update(t->L, l, r, add);
	else if (l > mid)	update(t->R, l, r, add);
	else update(t->L, l, mid, add), update(t->R, mid + 1, r, add);

	//下面这一句不知道有没有加的必要
	//唔，应该是有的
	t->val = max(t->L->val, t->R->val) + t->lazy;
}

void push(Node*& t) {
	if (t->l == t->r)	return ;
	t->L->val += t->lazy;
	t->L->lazy += t->lazy;
	t->R->val += t->lazy;
	t->R->lazy += t->lazy;
	t->lazy = 0;
}

long query(Node*& t, int l, int r) {
	push(t);
	if (t->l == l && t->r == r) {
		return t->val;
	}

	int mid = (t->l + t->r) >> 1;
	if (r <= mid)	return query(t->L, l, r);
	else if (l > mid)	return query(t->R, l, r);
	else return max(query(t->L, l, mid), query(t->R, mid + 1, r));
}
Node* t;
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	t = (Node*)malloc(sizeof(Node));
	cin >> n;
	for (int i = 1; i <= n; ++i) cin >> a[i];
	build(t, 1, n);

	int type, l, r;
	long add;
	cin >> n;
	while (n--) {
		cin >> type >> l >> r;
		if (type == 2) cout << query(t, l, r) << '\n';
		else {
			cin >> add;
			update(t, l, r, add);
		}
	}
}
```

# zkw线段树

### 在线更新

```c++
#include <iostream>
#include <cstring>
#include <string>
#include <cstdio>
using namespace std;
string s;
const int MAX = 1e6 + 5;
struct Node {
	int l, r, ans;
	Node(int a = 0, int b = 0, int c = 0): l(a), r(b), ans(c) {}
}t[MAX * 2];
int n;
Node combine(Node& a, Node& b) {
	int add = min(a.l, b.r);
	return Node(a.l - add + b.l, b.r - add + a.r, a.ans + b.ans + add); 
}
void build(int n) {
	for (int i = n - 1; i > 0; --i)
		t[i] = combine(t[i<<1], t[i<<1|1]);
}
Node query(int l, int r) {
	Node L, R;
	for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
		if (l&1)	L = combine(L, t[l++]);
		if (r&1)	R = combine(t[--r], R);
	}
	return combine(L, R);
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> s;
	n = s.size();
	for (int i = 0; i < n; ++i) {
		if (s[i] == '(')
			t[i + n] = Node(1, 0, 0);
		else	
			t[i + n] = Node(0, 1, 0);
	}
	build(n);

	int k, l, r;
	Node ans;
	cin >> k;
	while (k--) {
		cin >> l >> r;
		ans = query(l - 1, r);
		cout << ans.ans * 2 << '\n';
	}
}
```

### 求逆序对

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
const int MAX = 1e6 + 5;
int t[MAX<<1], n;
void update(int x) {
	for (t[x += n]++; x > 1; x >>= 1) {
		t[x>>1] = t[x] + t[x^1];
	}
}
int query(int l, int r) {
	int ans = 0;
	for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
		if (l&1)	ans += t[l++];
		if (r&1)	ans += t[--r];
	}
	return ans;
}

int a[MAX];
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n;
	for (int i = 1; i <= n; ++i)	cin >> a[i];
	long long ans = 0;
	for (int i = 1; i <= n; ++i) {
		if (a[i] != n)	ans += query(a[i] + 1, n + 1);
		// cout << ans << endl;
		update(a[i]);
	}

	// cout << ans << endl;

	if (n&1) {
		if (ans&1)	cout << "Petr";
		else	cout << "Um_nik";
	} else {
		if (ans&1)	cout << "Um_nik";
		else	cout << "Petr";
	}
	return 0;
}
```



# 逆元 + 组合数

```c++
const int mod=1e9+7;
int extgcd(int a,int b,int &x,int &y){
    int d=a;
    if(b!=0){
        d=extgcd(b,a%b,y,x);
        y-=(a/b)*x;
    }
    else    x=1,y=0;
    return d;
}
int inv(int a){
    int x,y,d=extgcd(a,mod,x,y);
    x=(x%mod+mod)%mod;
    return x;
}
int fac[200005];

int fun(int a,int b){
    int x=inv((1LL*fac[b]*fac[a-b])%mod);
    return (1LL*fac[a]*x)%mod;
}
```

# 最短路

```c++
//Dijkstra（无负边时的最短路问题） 
const int INF=0x3f3f3f3f;
const int N=1e5+10;

vector < pair<int,int> > E[N];
int n,m;
int d[N];
bool vis[N];

void init(){
    memset(vis,0,sizeof(vis));
    for(int i=0;i<N;i++) d[i]=INF;
    for(int i=0;i<N;i++) E[i].clear();
}

void dijkstra(int s,int d[]){
    priority_queue < pair<int,int> > Q;
    d[s]=0;
    Q.push(make_pair(-d[s],s));
    
    while(!Q.empty()){
        int now=Q.top().second;
        Q.pop();
        if(vis[now]) continue;
        vis[now]=1;
        for(int i=0;i<E[now].size();i++){
            int v=E[now][i].first;
            int D=d[now]+E[now][i].second;
            if(d[v]>D){
                d[v]=D;
                Q.push(make_pair(-d[v],v));
            }
        }
    }
}
```

# 最小生成树

```c++
const int N=1e5+10;
vector < pair<int,int> > E[N];
bool vis[N];

void init(){
    memset(vis,0,sizeof(vis));
    for(int i=0;i<N;i++) E[i].clear();
}

//起点为1
int prim(){
    int res=0;
    priority_queue < pair<int,int> > Q;
    for(int i=0;i<E[1].size();i++){
        int u=E[1][i].first;
        int d=E[1][i].second;
        Q.push(make_pair(-d,u));
    }
    vis[1]=1;
    while(!Q.empty()){
        int now=Q.top().second;
        int D=Q.top().first;
        Q.pop();
        if(vis[now]) continue;
        vis[now]=1;
        res=res+(-D);
        for(int i=0;i<E[now].size();i++){
            int u=E[now][i].first;
            int d=E[now][i].second;
            Q.push(make_pair(-d,u));
        }
    }
    return res;
}
```

# 数学

### 费马小定理

```c++
gcd(a,p)=1,那么a^(p-1)==1(mod p)
mypow(a,k*(mod-2)) = mypow(a,k*(mod-2)%(mod-1));
```

### Cantor展开

```c++
int fac[]={1,1,2,6,24,120,720,5040,40320,362880};
int cantor(string s){
    int temp,num;
    num=0;
    for(int i=0;i<n-1;i++){//n为位数
        temp=0;
        for(int j=i+1;j<n;j++){
            if(s[j]<s[i]) temp++;
        }
        num+=fac[n-i-1]*temp;
    }
    return (num+1);
}

void getstr(int val){
    int tmp[10],flag[10];
    memset(flag,0,sizeof flag);
    for(int i=0;i<9;i++) tmp[i]=val/c[8-i],val=val%c[8-i];
    for(int i=0;i<9;i++){
        int num=0;
        for(int j=0;j<9;j++){
            if(flag[j]==0) num++;
            if(num==tmp[i]+1){
                t[i]=j+'0'+1; if(t[i]=='9') t[i]='x';
                flag[j]=1;break;
            }
        }
    }
}
```



# 图论

### Trajan O(E + V)

#### 带环有向图缩点形成DAG

```c++
int number[MAX], head[MAX], cnt, low[MAX], s[MAX], top, scc, belong[MAX];
void dfs(int u) {
	number[u] = low[u] = ++cnt;
	int v;
	s[++top] = u;
	for (int i = head[u]; i; i = e[i].nex) {
		v = e[i].to;
		if (!number[v]) {
			dfs(v);
			low[u] = min(low[u], low[v]);
		} else if (!belong[v])	{
			low[u] = min(low[u], number[v]);
		}
	}

	int x;
	if (low[u] == number[u]) {
		++scc;
		while (true) {
			x = s[top--];
			belong[x] = scc;
			size[scc]++;
			if (x == u)	break;
		}
	}
}
void buildGraph() {
	cnt = 0;
	int v;
	for (int i = 1; i <= n; ++i) {
		for (int j = head[i]; j; j = e[j].nex) {
			v = e[j].to;
			if (belong[v] != belong[i])	add2(belong[i], belong[v]);
		}
	}
}
void trajan() {
	for (int i = 1; i <= n; ++i) {
    	if (!number[i])	dfs(i);
    }
}
```

#### 求割点

当一个点是割点，需要满足的两个条件

**1)** u is root of DFS tree and it has at least two children. 

**2)** u is not root of DFS tree and it has a child v such that no vertex in subtree rooted with v has a back edge to one of the ancestors (in DFS tree) of u.

```c++
void dfs(int u, int fa) {
	low[u] = number[u] = ++cnt;
	int v, child = 0;
	for (int i = head[u]; i; i = e[i].nex) {
		v = e[i].idx;
		if (!number[v]) {
			dfs(v, u);
			low[u] = min(low[u], low[v]);
			child++;
			if (low[v] >= number[u])	scc[u]++;
		} else if (number[v] < number[u] && v != fa) {
			low[u] = min(low[u], number[v]);
		}
	}

	if (child == 1 && fa == -1)	scc[u] = 0;
}
```

在该程序退出之后，如果scc[idx] != 0，那么该点就是割点

### Hungarian O(E$\cdot$V)

* 建图的时候只需要建立从左往右的点即可
* 在for循环中也只需要遍历左边的点即可
* 左右两边的点，对应的标记不可以相等

```c++
int match[MAX], vis[MAX];
bool dfs(int now) {
	vis[now] = 1;
	int v;
	for (int i = head[now]; i; i = e[i].nex) {
		v = e[i].to;
		if (match[v] == -1 || !vis[match[v]] && dfs(match[v])) {
			match[now] = v;
			match[v] = now;
			return true;
		}
	}
	return false;
}
int hungarian() {
	int ans = 0;
	memset(match, -1, sizeof(match));
	for (int i = 1; i <= n; ++i) {
		if (match[i] == -1) {
			memset(vis, 0, sizeof(vis)); // 可以使用技巧优化掉这个n
			if (dfs(i))	++ans;
		}
	}
	return ans;
}
```



# 计算几何

#### Graham's Scan 求凸包

1. 找到最下边的点，如果有多个点在同一y值，那么选取最左边的点

2. 以找到的点为参考点，将所有的点按照极角进行排序，方法是使用叉积

   我第一次写板子的时候没有处理好点的起点下标，果然还是从1开始比较人道

3. 使用单调栈的思路维护一个栈，该栈中最后剩下的点即为凸包

```c++
#include <iostream>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <string>
#include <algorithm>
using namespace std;
const double PI = acos(-1.0);
const double EPS = 1e-6;
const int MAX = 1005;
struct Point {
	int x, y;
	void in() {
		scanf("%d%d", &x, &y);
	}
}p[MAX];
int n, L;
int xmult(Point p0, Point p1, Point p2) {
	return (p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y);
}
double dis(Point a, Point b) {
	double dx = a.x - b.x;
	double dy = a.y - b.y;
	return sqrt(dx * dx + dy * dy);
}
bool cmpAngle(Point a, Point b) {
	int temp = xmult(p[1], a, b);
	if (temp > 0)	return true;
	else if (temp == 0 && dis(p[1], a) < dis(p[1], b))	return true;
	return false;
}
void in() {
	scanf("%d%d", &n, &L);
	p[1].in();
	int low = 1;
	for (int i = 2; i <= n; ++i) {
		p[i].in();
		if (p[i].y < p[low].y || (p[i].y == p[low].y && p[i].x < p[low].x))
			low = i;
	}
	if (low != 1)	swap(p[1], p[low]);
	sort(p + 2, p + 1 + n, cmpAngle);
}
int s[MAX], top = 0;
void graham() {
	double ans = 0;
	s[0] = 1;
	s[1] = 2;
	top = 2;
	for (int i = 3; i <= n; ++i) {
		while (top >= 2 && xmult(p[s[top - 2]], p[s[top - 1]], p[i]) <= 0)	--top;
		s[top++] = i;
	}
}
```



# 注意事项

1. 读题！读题！读题！有没有地方是理解错了的！  (二进制  ->  十进制)
2. Debug  -> 看看有没有什么变量拼错了，搞成了另外一个变量 !!!
3. 链式前向星，注意开双倍大小!! 在二分图建模时可能会是平方大小!!!
4. 输出的格式对不对!!! "YES"  "NO"
5. zkw线段树，传入的区间是左闭右开
####
