### qhb的个人笔记!~ 使用zkw线段树需要注意的地方

1. 首先是记得要把数组开成最大存储的两倍，毕竟是要建树

2. 在build函数和update函数中，两者的实现方式尽管都是自下而上，但是仍然有差别

   在build函数中，进行的是自下而上遍历所有的根结点，使用它们的子结点来进行更新。同时，要注意到这一课线段树最上面的根结点是1，所以在1的地方停止

   ```c++
   void build() {
    	for(int i = n - 1; i > 0; --i)
           t[i] = t[i<<1] + t[i<<1|1];//因为知道'i<<1'是一个偶数，所以对于另外一个子结点就是或
   }
   ```

   在update函数中，使用的是从子结点得到跟结点，再使用子结点更新根结点的方式

   ```c++
   void update(int x, int val) {
       for(t[x += n] = val; x > 1; x >>= 1) 
           t[x>>1] = t[x] + t[x^1];
   }
   ```

   因为此处使用的始终是从子结点得到根节点再更新，所以在x为1之前停止。也就是说，不可以更新x为1的情况。

3. 使用zkw线段树，是不需要对线段树数组进行初始化的，因为所有需要使用到的值都会在build函数和读入数据的时候完成更新。

# Problem E

#### qhb

第一次使用zkw线段树完成结点染色问题，写起来真是方便啊

然后在实现的思路上面，跟正常的递归式线段树差不多，只是这里为自下而上地传递标记而已

类似于求区间和，进行颜色标记的时候，是对满足某种性质的结点进行操作

在最后需要得到整个区间的颜色情况时，需要一个push函数，作用是把所有的标记都进行下移

注意，标记是有先后顺序的，必须同时维护一个时间戳，表示区间颜色的先后问题

# Problem F

#### qhb

这是一道区间染色的问题，跟上面的对结点染色情况不同，此时应该把每一个长度为1的染色区间视为一个结点。这样以来，就可以又回归为结点染色问题了

这样做的原因是对区间染色比较烦，并且线段树的叶子保存的本来就是结点，如果在区间染色问题里面再把线段树的叶子视为区间，那么会非常抽象，思考起来对人类不友好

本题的数据似乎有些水，因为看不到使用递归版线段树和zkw线段树的差别

# Problem H

#### qhb

相对于上题的时间戳，本题的区间操作是永久性操作，不存在覆盖的性质

并且由于在区间修改操作中，还间隔存在着查询操作，所以就必须在每次区间操作之后，加上一个up操作

来实现由于本次修改操作对原树造成的影响上传，保持整棵树的一致性

---

本题我使用了对拍的方法来发现这个问题