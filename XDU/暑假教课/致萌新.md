[TOC]

# Problem A HDU3038

题目描述：给出一段包含n个元素的序列，初始各个元素的值未知。之后给出m个信息，格式为`l, r, sum`

表示范围是`[l, r]`范围元素的加和为`sum`

依题目中给定的信息次序处理，如果遇到矛盾的信息无视

要求统计给出的m条信息中的矛盾信息的个数。



解法：可以将题目整理到图论上面去，一连串相关的信息其实就是一条链，询问其中任意两点的信息，可以通过该两点距离父节点的距离来验证。即两点之间的距离是已知的，当且仅当它们处于同一条链当中。

但是对于两条链的合并如何处理呢？推导出一条普适的结论即可。

注意使用`find()`函数来进行路径压缩以及更新到达父节点的距离。

疑问：为什么在读入数据之后，需要将`l--`? 

因为对于父节点可能存在该点的值已知，但是在将来的多次路径压缩中，出现坏值。应该保证父节点的val值为0



# Problem B POJ 1182

题目描述：现在给出三个种族A, B, C，已知它们之间的关系是A吃B，B吃C，C吃A，构成了一种奇妙的环状关系。现在给出`n`个动物构成的`m`组信息。信息分为两种，第一种的形式为`1 u v`，表示`u`与`v`为同类；第二种的形式为`2 u v`，表示`u`吃`v`。试统计有多少组矛盾信息。

矛盾信息分为三类：

* 表示的信息为 某种动物吃自己
* 表示的动物编号大于`n`
* 与前述信息矛盾的信息



解法：使用种类并查集来处理该问题。将并查集的大小扩大为原来的3倍。`[1, n]`表示A种族，`[n + 1, 2n`]表示B种族，`[2n + 1, 3n]`表示C种族。实际上这只是为了便于理解，只要可以构成环形的关系即可。

* 在给定的一组关系中，一个对象可能处于这三个种族的任意一个，所以当给定一个关系时，有必要在此处的三个可能中进行更新。

* 一个标号为`x`的对象在三个种族总都存在投影，分别为`x`, `x + n`, `x + 2n`

* 如果有`find(x) == find(y + n)`，即x为A种族，y为B种族，它们处于同一个集合，那么表示x吃y

* 举例：表示一个同类关系`1 u v`时，需要更新三个关系

  `unit(u, v), unit(u + n, v + n), unit(u + 2n, v + 2n)`

  分别表示u v均为A种族并且同类，u v均为B种族并且同类，u v均为C种族并且同类

* 如何判断给定的信息与前述信息矛盾？以同类为例

  可能出现的不匹配现象是

  * u 吃 v

    `find(u) == find(v + n) || find(u + n) == find(v + 2 * n) || find(u + 2 * n) == find(v)`

  * v 吃 u

    `find(v) == find(u + n) || find(v + n) == find(u + 2 * n) || find(v + 2 * n) == find(u)`

    



# 洛谷 P1525

题目描述：给出m对矛盾关系，形式为`a, b, val`。如果将这两个对象放在同一个集合中，将会产生数值为`val`的矛盾值。要求构造一种分配方式，将n个元素分配到两个集合中，最小化最大矛盾值。



解法：大意与食物链一致，虽然有两个集合，但是不必要关心某个对象具体分配到了哪个集合中，因为只是一个参照的关系。所以两倍并查集的大小，`[1, n]`元素代表同类关系，`[n + 1, 2n]`代表对应的敌对关系。

* 第一个步骤很明显是排序
* 之后按照次序处理矛盾关系，有一点贪心的思想。如果可以化解矛盾，则化解矛盾，即将两者设置为敌对关系，也就是不放到同一个集合中
* 否则直接输出此时的矛盾值即可，可以保证此时的矛盾值即为不可调和的最大矛盾值。



# Problem C POJ 2492

题目描述：给出一个假设，bug们都是异性恋，也就是说，存在交流的两种bug一定性别不同。给出n只bug的m对交流信息，格式为`u, v`，表示标号为`u`, `v`的两只bug存在交流。如果根据给定的信息可以判断出全部都是异性交流，那么输出`No suspicious bugs found!`；如果发现了同性交流，那么输出`Suspicious bugs found!`。注意在每个样例之后多输出一个空行。

题解：裸的种族并查集；注意输出格式，最后有一个空行

# Problem D POJ 1456

题目描述：在市场上销售物品。每个物品给出它的价值和销售的最晚时间，格式为`val, t`。销售一件物品需要消耗1单位的时间。试最大化利润。

题解：使用贪心策略。首先按照利润的大小对物品进行排序。之后贪心地将物品的销售安排在最晚销售时间之前即可。

问题的关键是如何快速地判断某个时间是否被占用，以及在该时间之前是否还有可用时间。这里提供两种实现方法

* 并查集：将每个时间点视为单个的元素。如果使用过了某个时间，那么将该时间与前一单位的时间连边，使用并查集将它们搞到一个集合中去，并且始终维护集合的代表元素为最早时间。

  一个物品的销售是可以被安排的，当且仅当其对应的时间点所在集合的代表元素非0。

* 线段树：实际上就是一个查询区间最大值的操作，思路同上。



# trajan详解

参照  `论文/trajan/README`   markdown文件

# Problem E POJ 1523

题目描述：求割点，以及该割点连接的连通分量个数

注意对非根结点以及根结点分类讨论即可

trajan算法需要适当做出修改，因为本题给出的是一棵无根树

# Problem F HDU 2767

题目描述：给出一个有向图，试求最少添加多少条边可以使得该图称为强连通图。

简化版本：给出一个DAG，试求最少添加多少条边可以使得该图称为强连通图。



大胆猜测，不用证明！

结论就是在一个DAG中，最少添加`max(出度为0的点, 入度为0的点)`，就可以达成目标

那么在trajan算法的帮助下，我们可以使用缩点操作，将存在环的有向图转化为DAG

之后得到入度为0的点以及出度为0的点的个数，本题即破

# Problem G Uva 11324

题目描述：给出一个含圈的有向图，试求其最长路

题解：由于DAG的最长路求解是一个经典的问题，考虑向哪方面靠拢

环的存在其实可以等价于一个点，只是该点的权值不再是1，而是环中包含的点的个数

使用trajan算法缩点之后对DAG求最长路即可



# Problem H POJ 1751

题目描述：给出一个包含n个结点的图，初始的时候包含有m条边，试求该图的最小生成树，并且给出新加的边。

题解：最小生成树模版。注意这是一个完全图，要有正确的加边姿势

# Problem I Uva 1151

题目描述：给出一个包含n个结点的图，给出每个节点的坐标信息。连接每对结点需要的花费为之间距离的平方。初始图中不含任何边。除了上述信息之外，题目还提供了q种方案，每种方案有一定的费用；购买方案可以得到其中包含的边集。试求图的最小生成树。

题解：q比较小，所以对于采取哪些方案，可以暴力枚举。

问题的关键是对于每个枚举出的方案，如果快速得到采取该方案对应的最小生成树

思考不采取任何方案得到的最小生成树

将来在采取方案的时候，候选的边集也只会是这个最小生成树中包含的边集



# Problem J Uva 1395

题目描述：给出一个图，试求其一个生成树，最小化最大边减去最小边的差值

题解：由于数据规模比较小，所以可以使用比较暴力的方法

固定最小边，枚举出对应该最小边的所有最小生成树

这样做的正确性，可以用瓶颈生成树来直观地理解

> 瓶颈生成树 
>
> 无向图G的一颗瓶颈生成树是这样的一颗生成树，它最大的边权值在G的所有生成树中是最小的。
>
> 无向图的最小生成树一定是瓶颈生成树，但瓶颈生成树不一定是最小生成树。

首先对边从小到大排序，从左到右枚举最小边，计算过之后默认将该边删除，不予考虑

根据瓶颈生成树，对应于某个图的最小生成树就是瓶颈生成树，所以可以保证此时最大边最小

于是这样依次枚举，即可得到答案





