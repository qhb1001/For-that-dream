# Problem B(POJ 3573)

# Problem C (CERC 2017  problem A)

http://codeforces.com/gym/101620

# Problem E(POJ 3569)

#### qhb

为了这道题目在学表达式树，学了三四个小时的样子

现在感觉对建树的过程已经理解了，记录一下

核心的思想是寻找“最后一个运算符号”

拿加减乘除来讲，在将整个表达式化简之后最后也不过是两个数之间的加减乘除

在递归构建表达式树的过程中，大概是以下的流程

* 首先判断目前的区间是否为单独的一个数字，若是，则构成叶结点，否则执行以下过程
* 在区间内从左往右遍历，维护一个变量，表示目前光标是否被括号包围。如果没有被括号包围，并且扫到了加减，更新c1变量；如果扫到了乘除，更新c2变量
* 遍历完整个区间之后，如果没有遇到加减，那么使用乘除号；如果仍然没有遇到乘除号，那么说明整个区间被括号覆盖，左右边界各缩小一；否则执行以下过程
* 在筛选到的运算符左侧建树，在运算符右侧建树

---

在学习刘汝佳的代码中，我越来越体会到不使用结构体指针进行建树的优点：节省空间，操作性好

然后这整个套路、递归的思想也是值得学习的

---

然而，在紫书里配对表达式树的题目太难。。目前我还没有办法做出来

# Problem F(NEERC 2008 problem F)

http://codeforces.com/gym/100286

# Problem H(Uva 1614)

#### qhb

题目描述：给出一个大小为n的数列，并且这个数列中的元素满足$a[i] <= i$，试求是否存在一种方案，使得在某些数字前面加上正号，某些数字前面加上负号，使得最后的和为0

首先，对于这个数列，有一个很神奇的结论：如果对应该数列位置 $i$ 前缀和为$pre[i]$，那么可以保证，前 $i$ 个元素可以得到$1 - pre[i]$范围内的所有和

上述结论可以通过简单地枚举特例发现，也可以通过数学归纳法证明

---

在得到上述结论之后。。题解里面使用了贪心，贪心地取大值，能取则取，不能取就不取。。然后就A了。。

不明白这个贪心的正确性



