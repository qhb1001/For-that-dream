# Problem B(POJ 3573)

题目描述：定义一种单词的缩写方式：只保留首字母和尾字母，中间的字母使用数字替代。然后给出至多1000行的输入，每行由一些单词组成，它们之间的间隔可以是空格，也可以是其他符号。现在要求按照给出的串的顺序进行处理，如果遇到了某一个缩写形式的单词，如果没有二义性，并且可以进行展开，那么就将该单词进行展开；否则不进行处理。

整体上，读入和处理我分为了两步

在处理的时候，我使用了map从缩写形式映射到原形式，之后使用了一个set，用来存储具有二义性的缩写形式

# Problem C (CERC 2017  problem A)

http://codeforces.com/gym/101620

题目描述：给出几条不具有二义性的原则，要求按照该原则给飞机上的乘客排座位。

因为从根本上来说，是对座位的优先级进行排序的，所以可以想一想把整个挑选座位的过程

搞成一个大排序，但是考虑到排序的过程中需要使用到全局变量：整个飞机中左半边的人，右半边的人，某一行的人

所以必须在每次取出头部元素之后重新排序

---

在code的过程了犯了一个很基础的错误：对`if`的逻辑判断把握错了

本意是如果目前选中的座位在左半边，那么把左半边的人数加1，否则把右半边的人数加1

但是忘记考虑中间那一列的情况了。。导致这个`if  else`逻辑判断将中间也算成了右边

正确的判断应该是`if   else if`这样的

# Problem E(POJ 3569)

#### qhb

为了这道题目在学表达式树，学了三四个小时的样子

现在感觉对建树的过程已经理解了，记录一下

核心的思想是寻找“最后一个运算符号”

拿加减乘除来讲，在将整个表达式化简之后最后也不过是两个数之间的加减乘除

在递归构建表达式树的过程中，大概是以下的流程

* 首先判断目前的区间是否为单独的一个数字，若是，则构成叶结点，否则执行以下过程
* 在区间内从左往右遍历，维护一个变量，表示目前光标是否被括号包围。如果没有被括号包围，并且扫到了加减，更新c1变量；如果扫到了乘除，更新c2变量
* 遍历完整个区间之后，如果没有遇到加减，那么使用乘除号；如果仍然没有遇到乘除号，那么说明整个区间被括号覆盖，左右边界各缩小一；否则执行以下过程
* 在筛选到的运算符左侧建树，在运算符右侧建树

---

在学习刘汝佳的代码中，我越来越体会到不使用结构体指针进行建树的优点：节省空间，操作性好

然后这整个套路、递归的思想也是值得学习的

---

然而，在紫书里配对表达式树的题目太难。。目前我还没有办法做出来

# Problem F(NEERC 2008 problem F)

http://codeforces.com/gym/100286

题目描述：给出一种自定义的进制 — Fibonacci进制。每一个数字都有唯一的编码。将1、2、3、…的Fibonacci编码排列在一起。试求前N位中1的个数。

贪心找规律

但是在找到规律之后，使用递归来得到答案，这个操作是在是太强了

应该是一道值得反复回味的题目

# Problem H(Uva 1614)

#### qhb

题目描述：给出一个大小为n的数列，并且这个数列中的元素满足$a[i] <= i$，试求是否存在一种方案，使得在某些数字前面加上正号，某些数字前面加上负号，使得最后的和为0

首先，对于这个数列，有一个很神奇的结论：如果对应该数列位置 $i$ 前缀和为$pre[i]$，那么可以保证，前 $i$ 个元素可以得到$1 - pre[i]$范围内的所有和

上述结论可以通过简单地枚举特例发现，也可以通过数学归纳法证明

---

在得到上述结论之后。。题解里面使用了贪心，贪心地取大值，能取则取，不能取就不取。。然后就A了。。

不明白这个贪心的正确性



