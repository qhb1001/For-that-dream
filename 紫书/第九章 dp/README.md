# Problem A

题目描述：特工Maria要乘坐地铁！但是想要在车站上停留的时间尽可能少，也就是尽可能一直在列车上。并且想要在`T`时刻在最后一站，与另外一名特工碰面！现在给出列车的运行表，每相邻两站之间的运输时间是一定的，为`t_i`，表示从`i` 号车站到达`i + 1`号车站需要的时间。之后给出`m_1`辆列车的出发时间，表示它们什么时候从1号车站出发向n号车站行驶，之后给出`m_2`辆列车的出发时间，表示它们什么时候从n号车站出发向1号车站行驶。

### qhb

一年前没看懂的题目现在能写啦

首先预处理出在某个时刻某个车站是否有开往左边或者右边的车

之后模拟时间流逝，在每个时刻内，枚举每一个车站状态可以转移到的位置（我使用了刷表法，更新可以到达的状态）

具体的状态转移为对于某一时刻某一车站中的状态，它有三个转移方向

* 在原地呆一秒
* 如果有向左的列车，乘上它，更新状态
* 如果有向右的列车，乘上它，更新状态

由于状态中有零值的存在，所以初始化为-1，但是这样的话更新状态可能有些麻烦。然后想起了艾教的操作，重载`min`函数

```c++
int min(int a, int b) {
	if (a == -1)	return b;
	if (b == -1)	return a;
	if (a < b)	return a;
	return b;
}
```

注意初始化，比如对于`t`数组，如果不初始化为0，那么在预处理阶段有可能出现读入了上一个样例的数据

# Problem B

题目描述：给出N种长方体积木，并且规定一个积木可以摞在另一块积木上面，当且仅当下面积木的面完全包围上面积木的面。每一种积木都有无限多个。试求可以达到的最大高度。

### qhb

通过类似于断环为链的方法，将每一种积木都变换为3种，表示底面的三种可能组合。之后建立有向图，使用记忆化搜索寻找最长路即可。

我使用了链式前向星作为图的存储结构(感觉自己棒棒的...

# Problem C

### qhb

做不来的题目 - -  一年过去了也没有改变什么...

# Problem D

题目描述：给出一个规模为n, m的图，现在规定一个点的可移动范围，并且规定只可以从第i列走向第i+1列。试求最终路径的最小长度，并且打印最小字典序

### qhb

一年前似乎就因为字典序的问题犯了迷糊，如今似乎犯了完全相同的错误。。

使用pre记录前驱是无法得到最小字典序的！

目前来看最方便的方法是使用递归，dfs，记忆化搜索(其实是同一个东西

越早作出的决策，其优先级越大，而pre记录前驱的方法与其矛盾

# Problem E

题目描述：给出n首歌，以及时间限制t，每首歌都有一个时间长度，一旦选定必须全部唱完。求在t - 1时间内(经过题目转化之后是这样)，能够唱得最多的歌曲数目，并且输出对应的最晚可以滞留的时间。

### qhb

01背包！经过一年的时间，对这道题目也可以解啦！

似乎是一个裸的01背包

# Problem F

题目描述：最短回文串划分

### qhb

很容易可以得到一个O(n^2)的算法

# Problem G

题目描述：给出两个颜色序列，现在要求将两个颜色序列合并为一个串。针对该串定义一个权值，该权值是由***单独颜色最大距离***决定的。***单独颜色最大距离***表示针对该串中的每一个颜色，最左边对应的位置与最右边对应的位置之间的距离。最终的权值由每种颜色的该值加和决定。试求在合并之后可以得到的最小权值。

### qhb

根据刘汝佳对状态的设计，本题很像***旅游***那一道题目

针对当前的状态，可以维护目前有几种已经但是没有结束的元素

而上面这个东西可以使用每种颜色在各个序列中的开始和结束位置来得到

判断开始位置，是如果之前的状态都小于开始位置，当前状态有一个到达了开始位置，那么就对维护的值++

判断结束位置，如果之前有一个值小于结束位置，当前状态都大于等于结束位置，那么就对维护的值--

关于状态转移

首先初始化所有的$dp[0][i]$

之后递增第一维，枚举第二维

