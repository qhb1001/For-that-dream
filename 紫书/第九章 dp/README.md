# Problem A

题目描述：特工Maria要乘坐地铁！但是想要在车站上停留的时间尽可能少，也就是尽可能一直在列车上。并且想要在`T`时刻在最后一站，与另外一名特工碰面！现在给出列车的运行表，每相邻两站之间的运输时间是一定的，为`t_i`，表示从`i` 号车站到达`i + 1`号车站需要的时间。之后给出`m_1`辆列车的出发时间，表示它们什么时候从1号车站出发向n号车站行驶，之后给出`m_2`辆列车的出发时间，表示它们什么时候从n号车站出发向1号车站行驶。

### qhb

一年前没看懂的题目现在能写啦

首先预处理出在某个时刻某个车站是否有开往左边或者右边的车

之后模拟时间流逝，在每个时刻内，枚举每一个车站状态可以转移到的位置（我使用了刷表法，更新可以到达的状态）

具体的状态转移为对于某一时刻某一车站中的状态，它有三个转移方向

* 在原地呆一秒
* 如果有向左的列车，乘上它，更新状态
* 如果有向右的列车，乘上它，更新状态

由于状态中有零值的存在，所以初始化为-1，但是这样的话更新状态可能有些麻烦。然后想起了艾教的操作，重载`min`函数

```c++
int min(int a, int b) {
	if (a == -1)	return b;
	if (b == -1)	return a;
	if (a < b)	return a;
	return b;
}
```

注意初始化，比如对于`t`数组，如果不初始化为0，那么在预处理阶段有可能出现读入了上一个样例的数据

#### hcx

左右傻傻分不清！

# Problem B

题目描述：给出N种长方体积木，并且规定一个积木可以摞在另一块积木上面，当且仅当下面积木的面完全包围上面积木的面。每一种积木都有无限多个。试求可以达到的最大高度。

### qhb

通过类似于断环为链的方法，将每一种积木都变换为3种，表示底面的三种可能组合。之后建立有向图，使用记忆化搜索寻找最长路即可。

我使用了链式前向星作为图的存储结构(感觉自己棒棒的...

# Problem C

### qhb

做不来的题目 - -  一年过去了也没有改变什么...

# Problem D

题目描述：给出一个规模为n, m的图，现在规定一个点的可移动范围，并且规定只可以从第i列走向第i+1列。试求最终路径的最小长度，并且打印最小字典序

### qhb

一年前似乎就因为字典序的问题犯了迷糊，如今似乎犯了完全相同的错误。。

使用pre记录前驱是无法得到最小字典序的！

目前来看最方便的方法是使用递归，dfs，记忆化搜索(其实是同一个东西

越早作出的决策，其优先级越大，而pre记录前驱的方法与其矛盾

# Problem E

题目描述：给出n首歌，以及时间限制t，每首歌都有一个时间长度，一旦选定必须全部唱完。求在t - 1时间内(经过题目转化之后是这样)，能够唱得最多的歌曲数目，并且输出对应的最晚可以滞留的时间。

### qhb

01背包！经过一年的时间，对这道题目也可以解啦！

似乎是一个裸的01背包

### hcx

$t<={10}^9$其实是骗人的，由题意可将$t$的范围缩小至${10}^4$

# Problem F

题目描述：最短回文串划分

### qhb

很容易可以得到一个O(n^2)的算法

#### hcx

由于处理边界后，然后对于$n==1$的情况没有特判

# Problem G

题目描述：给出两个颜色序列，现在要求将两个颜色序列合并为一个串。针对该串定义一个权值，该权值是由***单独颜色最大距离***决定的。***单独颜色最大距离***表示针对该串中的每一个颜色，最左边对应的位置与最右边对应的位置之间的距离。最终的权值由每种颜色的该值加和决定。试求在合并之后可以得到的最小权值。

### qhb

根据刘汝佳对状态的设计，本题很像***旅游***那一道题目

针对当前的状态，可以维护目前有几种已经但是没有结束的元素

而上面这个东西可以使用每种颜色在各个序列中的开始和结束位置来得到

判断开始位置，是如果之前的状态都小于开始位置，当前状态有一个到达了开始位置，那么就对维护的值++

判断结束位置，如果之前有一个值小于结束位置，当前状态都大于等于结束位置，那么就对维护的值--

注意对两个序列都只出现了一次的颜色进行特判

关于状态转移

首先初始化所有的$dp[0][i]$

之后递增第一维，枚举第二维

---

上述观察并没有错误，关于具体实现可以写一个`check(int i, int j, int ii, int jj, int color)`函数，表示从上一个状态转移而来到目前的状态将会变化的颜色种类数

这样的话，就可以方便地完成更新，拿`i, j`  -> `i, j + 1`为例

```c++
dp[i][j + 1] = min(dp[i][j + 1], dp[i][j] + L[i][j] + check(i, j, i, j + 1, b[j]);
```

---

但是如果使用上述的刷表法，需要每次首先对dp数组进行初始化，但是由于数组大小为1e10的，所以这个开销吃不起

本来想着应该转换一下，从刷表法改到填表法，这样每次更新只需要从之前的两个状态里面取最小值就行了

但是突然悟了。。心里面突然出现了这道题的状态转移图

![Figure1](/Users/qinhongbo/Desktop/Github/For-that-dream/紫书/第九章 dp/Figure1.png)

然后发现在图中试着去理解填表法时，可以很清楚地看到正是因为当前状态是由前面两个状态转移来的，当前状态并没有初始值，所以可以直接进行转移，不需要对dp数组进行初始化

但是当使用刷表法时，我是按从上到下，从左到右的顺序进行状态转移的，在到达一个状态之后它也许会有初值，也可能没有…….. 等等！是否可以进行分类讨论呢！

继续观察可以发现，除去第一行，当我们到达一个状态之后，如果要进行向下的转移，那么状态是第一次更新；如果要进行向右的状态转移，那么该状态是第二次更新！

所以使用刷表法完全没有必要初始化dp数组了！

---

当年做紫书的dp专题时，因为这道题，把我卡得非常绝望… 然后放弃了

现在回头看看，实际上只有当dp功力达到一定阶段，才可以写这道题呐！

#### hcx

知道了memset也是有时间的，不可以神化STL的！

# 最优矩阵链乘 POJ1651

### qhb

脑袋里面首先想出来的dp是枚举最后一次矩阵乘法的长度，然而发现这个dp不正确

对于$(A_1 A_2 A_3)((A_4A_5)(A_6A_7))$这样的数据，就根本无法得到

果然还是要用刘汝佳的方式，最优矩阵链的长度作为阶段，当前阶段可能由之前的某两个阶段转移而来

作为区间dp的一道经典题目，对区间dp的特点很好地描述了：当前区间的最优解是由之前的小区间决定的

# Problem G

#### hcx

如果是在递归中的量，不要用全局变量！！！



# Problem H

#### hcx

输入输出调了好久！（没仔细看题目要求……

第一个 每样例后面空行隔开！

第二个 输入每样例空行隔开！

第三个 空行不能用cin.get()消去！原因应该在于`\n`是换行的意思！我记得当时回车和换行是不同的字符，所以如果两个cin.get()不知道可不可以！（试了好多次，vjudge让我输验证码了！我不是黑oj的呐！……）最后用了getline!

