[TOC]

# Problem A

题目描述：特工Maria要乘坐地铁！但是想要在车站上停留的时间尽可能少，也就是尽可能一直在列车上。并且想要在`T`时刻在最后一站，与另外一名特工碰面！现在给出列车的运行表，每相邻两站之间的运输时间是一定的，为`t_i`，表示从`i` 号车站到达`i + 1`号车站需要的时间。之后给出`m_1`辆列车的出发时间，表示它们什么时候从1号车站出发向n号车站行驶，之后给出`m_2`辆列车的出发时间，表示它们什么时候从n号车站出发向1号车站行驶。

### qhb

一年前没看懂的题目现在能写啦

首先预处理出在某个时刻某个车站是否有开往左边或者右边的车

之后模拟时间流逝，在每个时刻内，枚举每一个车站状态可以转移到的位置（我使用了刷表法，更新可以到达的状态）

具体的状态转移为对于某一时刻某一车站中的状态，它有三个转移方向

* 在原地呆一秒
* 如果有向左的列车，乘上它，更新状态
* 如果有向右的列车，乘上它，更新状态

由于状态中有零值的存在，所以初始化为-1，但是这样的话更新状态可能有些麻烦。然后想起了艾教的操作，重载`min`函数

```c++
int min(int a, int b) {
	if (a == -1)	return b;
	if (b == -1)	return a;
	if (a < b)	return a;
	return b;
}
```

注意初始化，比如对于`t`数组，如果不初始化为0，那么在预处理阶段有可能出现读入了上一个样例的数据

### hcx

左右傻傻分不清！

# Problem B

题目描述：给出N种长方体积木，并且规定一个积木可以摞在另一块积木上面，当且仅当下面积木的面完全包围上面积木的面。每一种积木都有无限多个。试求可以达到的最大高度。

### qhb

通过类似于断环为链的方法，将每一种积木都变换为3种，表示底面的三种可能组合。之后建立有向图，使用记忆化搜索寻找最长路即可。

我使用了链式前向星作为图的存储结构(感觉自己棒棒的...

# Problem C

### qhb

做不来的题目 - -  一年过去了也没有改变什么...

# Problem D

题目描述：给出一个规模为n, m的图，现在规定一个点的可移动范围，并且规定只可以从第i列走向第i+1列。试求最终路径的最小长度，并且打印最小字典序

### qhb

一年前似乎就因为字典序的问题犯了迷糊，如今似乎犯了完全相同的错误。。

使用pre记录前驱是无法得到最小字典序的！

目前来看最方便的方法是使用递归，dfs，记忆化搜索(其实是同一个东西

越早作出的决策，其优先级越大，而pre记录前驱的方法与其矛盾

# Problem E

题目描述：给出n首歌，以及时间限制t，每首歌都有一个时间长度，一旦选定必须全部唱完。求在t - 1时间内(经过题目转化之后是这样)，能够唱得最多的歌曲数目，并且输出对应的最晚可以滞留的时间。

### qhb

01背包！经过一年的时间，对这道题目也可以解啦！

似乎是一个裸的01背包

### hcx

$t<={10}^9$其实是骗人的，由题意可将$t$的范围缩小至${10}^4$

# Problem F

题目描述：最短回文串划分

### qhb

很容易可以得到一个O(n^2)的算法

### hcx

由于处理边界后，然后对于$n==1$的情况没有特判

# Problem G

题目描述：给出两个颜色序列，现在要求将两个颜色序列合并为一个串。针对该串定义一个权值，该权值是由***单独颜色最大距离***决定的。***单独颜色最大距离***表示针对该串中的每一个颜色，最左边对应的位置与最右边对应的位置之间的距离。最终的权值由每种颜色的该值加和决定。试求在合并之后可以得到的最小权值。

### qhb

根据刘汝佳对状态的设计，本题很像***旅游***那一道题目

针对当前的状态，可以维护目前有几种已经但是没有结束的元素

而上面这个东西可以使用每种颜色在各个序列中的开始和结束位置来得到

判断开始位置，是如果之前的状态都小于开始位置，当前状态有一个到达了开始位置，那么就对维护的值++

判断结束位置，如果之前有一个值小于结束位置，当前状态都大于等于结束位置，那么就对维护的值--

注意对两个序列都只出现了一次的颜色进行特判

关于状态转移

首先初始化所有的$dp[0][i]$

之后递增第一维，枚举第二维

---

上述观察并没有错误，关于具体实现可以写一个`check(int i, int j, int ii, int jj, int color)`函数，表示从上一个状态转移而来到目前的状态将会变化的颜色种类数

这样的话，就可以方便地完成更新，拿`i, j`  -> `i, j + 1`为例

```c++
dp[i][j + 1] = min(dp[i][j + 1], dp[i][j] + L[i][j] + check(i, j, i, j + 1, b[j]);
```

---

但是如果使用上述的刷表法，需要每次首先对dp数组进行初始化，但是由于数组大小为1e10的，所以这个开销吃不起

本来想着应该转换一下，从刷表法改到填表法，这样每次更新只需要从之前的两个状态里面取最小值就行了

但是突然悟了。。心里面突然出现了这道题的状态转移图

![Figure1](/Users/qinhongbo/Desktop/Github/For-that-dream/紫书/第九章 dp/Figure1.png)

然后发现在图中试着去理解填表法时，可以很清楚地看到正是因为当前状态是由前面两个状态转移来的，当前状态并没有初始值，所以可以直接进行转移，不需要对dp数组进行初始化

但是当使用刷表法时，我是按从上到下，从左到右的顺序进行状态转移的，在到达一个状态之后它也许会有初值，也可能没有…….. 等等！是否可以进行分类讨论呢！

继续观察可以发现，除去第一行，当我们到达一个状态之后，如果要进行向下的转移，那么状态是第一次更新；如果要进行向右的状态转移，那么该状态是第二次更新！

所以使用刷表法完全没有必要初始化dp数组了！

---

当年做紫书的dp专题时，因为这道题，把我卡得非常绝望… 然后放弃了

现在回头看看，实际上只有当dp功力达到一定阶段，才可以写这道题呐！

### hcx

知道了memset也是有时间的，不可以神化STL的！

# 最优矩阵链乘 POJ1651

### qhb

脑袋里面首先想出来的dp是枚举最后一次矩阵乘法的长度，然而发现这个dp不正确

对于$(A_1 A_2 A_3)((A_4A_5)(A_6A_7))$这样的数据，就根本无法得到

果然还是要用刘汝佳的方式，最优矩阵链的长度作为阶段，当前阶段可能由之前的某两个阶段转移而来

作为区间dp的一道经典题目，对区间dp的特点很好地描述了：当前区间的最优解是由之前的小区间决定的

# Problem I

题目描述：给出一根长度为`Len`的木棍，之后给出n个切割点，在操作完成之后，必须对每个切割点都进行一次切割，但是可以自己决策切割点的先后顺序。对于每次切割，将会花费一个与当前**切割**木棍长度相等的权值。试求在切割之后，如何可以达到最少的花费

### qhb

可以很明显地看到该题与上面那题的类似

关于如何进行状态转移，可以类似地定义一个$dp[n][n]$这样的状态，由于切割点自带长度信息，所以在记忆化搜索过程中不必要记录多余的长度信息。

注意边界条件，当`l + 1 == r`时，返回0

由于一旦选择一个切割点之后，这个点就不会再使用了，所以在dfs中使用的应该是开区间

所以一开始，调用的dfs函数为`dfs(0, n + 1)`

### hcx

如果是在递归中的量，不要用全局变量！！！

# Problem J

题目描述：定义一种正规的括号序列。接着给出一个长度为len的串，试求最少添加多少个括号可以使其成为正规括号序列。

### qhb

注意到对于一个区间`l  r`，它的最优解可以用以下的形式转移而来

```c++
for (int k = l + 1; k < r; ++k) {
	dp[l][r] = min(dp[l][r], dp[l][k] + dp[k + 1][r]);
}
```

而上式与矩阵链乘的状态一致，所以记忆化搜索即可(具体实现还需要考虑最外面的两个符号匹配成功的情况)

---

本题还存在一个打印路径的问题，操作方法可以使用递归来完成

相当于在一个DAG图中寻找某些符合条件的边

### hcx

输入输出调了好久！（没仔细看题目要求……

第一个 每样例后面空行隔开！

第二个 输入每样例空行隔开！

第三个 空行不能用cin.get()消去！原因应该在于`\n`是换行的意思！我记得当时回车和换行是不同的字符，所以如果两个cin.get()不知道可不可以！（试了好多次，vjudge让我输验证码了！我不是黑oj的呐！……）最后用了getline!

---

关于cin，getline，cin.get()的区别

最后一个如果不接受任何参数，是用来读取单独字符的，在读完之后缓冲区不会残留任何东西

第二个是用来读取一整行的，读完之后也不会残留任何东西

第一个是用来读取规格化数据的，以int为例，如果目前程序中是`cin >> a;`

* 当输入是"123"的时候，在缓冲区将会残留一个换行符
* 当输入是"123 "的时候，相对上面多了一个空格，最缓冲区将会残留一个空格，一个换行符



# 树的最大独立集  HDU 1520

题目描述：给出一棵树(也可以是一个棵无根树，但当随意选定一个结点跑一遍dfs之后仍然可以得到一棵有根树，两者对该题等价)，给每一个结点一个权值，可正可负。现要求选定一个结点集合，使得它们的权值相加最大。该结点集合中不可以存在相邻的结点。也就是说，当选定一个结点之后，它的所有儿子结点都不可选，其父结点也不可选。

### qhb

设计状态为$dp[flag][node]$  第一维有两个值  0 - 不取该点   1 - 取该点。 第二维表示哪个结点

由于某结点的值是由其子树转移而来的，所以有

$\begin{cases} dp[1][now] = val[now] + \sum dp[0][k] \\ \\ d[0][now] = \sum max\{dp[0][k], dp[1][k] \}\end{cases}$

由于因为可能存在负值，所以当不取该结点时，其儿子结点可取可不取

上述状态转移方程使用递归实现很简单，并且不需要记忆化搜索

# 树的重心  POJ 1655

题目描述：定义一棵树的重量为这棵树中的结点数量。定义一棵树的重心为，删去该重心之后得到的森林，各棵树中重量的最大值，相对删去其他点得到的最大值最小。换句话说，删除这个点后最大联通块的结点数最小。

### qhb

思考如何得到，删去某一个点之后，相对该点的最大联通块结点数。

可以回忆割点中的操作，当删去一个割点之后，在一棵树中除去根结点，每个结点都会产生与其相连结点个数的联通分量个数。

相对于本题，当删去某个结点之后，形成的树除了其子结点，还有其父结点一棵。

所以如果令$d[node]$保存从该点出发可以到达的结点数，那么可以得到相对于该点的最大联通块结点数

$value = max(max\{ d[v]\}, n - d[node])$

---

在我的代码中，我使用了`getTree`函数来得到一棵有根树

这个函数接受的参数有两个，一个是当前结点，一个是该结点的父结点

依次不需要使用vis数据就可以完成建立有根树的过程

---

但是在看到kuangbin的代码之后。。。发现根本就不需要特意转化为有根树。。

因为在搜索的时候，只需要也维护一个fa参数即可。。。

树上dp真是神奇呐

# 树中任意结点的最大距离  HDU 2196

题目描述：给出一棵无根树，对于每个结点，在树中都存在一个最远可以到达的距离，试求对应每个结点的最大距离

### qhb

思考：一个结点的最远距离可能从哪里得到？

可能是从该结点的子结点转移而来的，也可能是从父结点那里转移而来的。前者直接取子结点最大距离的最大者加一即可，后者也许是从父结点的一棵子树中转移而来，也可能从父结点的父结点那里转移而来。

定义：对于一个结点，其最大距离表示从该结点出发，可以到达的最大距离(2333 表面意思咯)

定义：对于一个结点，其次大距离表示从该结点出发，不经过可以到达最大距离的 子结点或者父结点，可以到达的最大距离。注意，两者的值也许出现相等的情况

如果设计状态为$dp[type][n]$，$\begin{cases} 最大距离  & type = 0 \\ 次大距离 & type = 1 \\ 从父结点出发的最大距离  & type = 2\end{cases}$   

那么对于一个结点，其最大距离为$max\{dp[0][n], dp[2][n]\}$

首先使用一次dfs得到每个结点的最大距离和次大距离

之后再使用得到的上述两个值以及辅助的一个值得到父结点最大值

---

存在一个问题，只有当视该树为无根树，每一条边视为双向边时才可以A掉

而当加入的是单向边就会WA

这个问题问过毛老师了，等待回复啦

---

。。原来那个是BUG。。在加边的时候我加反了。。导致这棵有根树没有建对。。

所以事实上加单向边也是可以的

毛老师被我的bug搞晕了2333 不过给我展示了一个trick

```c++
add(min(i, v), max(i, v), w);
```

慢慢体会吧！

# Problem L

题目描述：在一个公司里面，除了开公司的大老板，每一个员工都有且仅有一个直接上级。现给出一个数值T，当一个小老板的下属中有大于等于T%的员工请求提升工资时，这个小老板也会向他的上级请求提升工资。试求如果大老板需要对整个公司提升工资时，需要的最少请愿工人。

### qhb

这道题对当前状态的转移十分明确，当已知各个下属请愿需要的花费，从下属中挑出需要的最少请愿下属即可。

实现上面可以直接sort

# Problem M

题目描述：题干与树的最大独立集一致，只是多了一个询问。最终的方案是否唯一。

### qhb

只要乖乖地分类讨论就行啦

对于取当前结点的状态，从不取子结点中转移而来，如果子结点中有一个方案不唯一，对应于该状态则不唯一

对于不取当前结点的状态，从不取子结点与取子结点都可以转移而来，如果两者相等，那么方案不唯一；如果大者方案不唯一，那么该状态方案不唯一

此题即破

# Problem N

题目描述：给出一棵无根树，可以选择其中某些结点作为服务器。要求对于每一个非服务器结点，必须连接一个并且仅一个服务器结点。求最少可以选择多少个服务器结点。

### qhb

由于一个结点必须与一个服务器结点相连，所以必须处理

* 一个结点两边都是服务器结点
* 服务器 - 非 - 非 - 服务器

这两种情况

设计状态为$dp[3][n]$

0 - this node is a server

1 - its father is a server, it is not a server 

2 - both its father and it are not server

---

初始化条件

$dp[0][idx] = 1  $    $dp[1][idx] = 0$   $dp[2][idx] = inf$ 

后者如此设置是为了防止出现全空的情况

# 习题部分

# Problem A

水题

# Problem B

题目描述：Little Bob面对着四堆糖果，在纠结怎么样才能把它们全都带回家！取糖果的规则是这样的，每次只能在堆顶取糖果，取糖果之后放到Little Bob的手上，如果手上有两块颜色相同的糖果，那么Little Bob将会把它们装到自己的口袋里面。手上最多只可以有五颗糖果，口袋无限大。问最后口袋里最多可以放多少对糖果？

### qhb

设计状态为$dp[a][b][c][d]$，表示目前第一堆取了a个糖果，第二堆取了b个糖果……  对应的最优答案。

由于状态如此规定之后，不存在tie，所以只要可以转移就进行转移

就这样进行深搜，模拟取糖果的过程即可

---

* 我自己写的时候没有好好利用dfs的性质，而是用了跟递推一样的思路，记录每一个状态对应的取出的糖果

  事实上，由于是记忆化搜索，所以是可以动态维护这个取出的糖果的

  具体实现就是维护四个cnt，对应某一堆目前取到了哪一个糖果

* 写的时候脑袋晕了，上下颠倒。实际上边的idx值较小，下面的idx值较大

* 这道题的Time Limit是30s…...

